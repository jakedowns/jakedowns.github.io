<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Video Rainbow - Blended Hue Shift</title>
  <style>
    body { background: #111; color: #fff; font-family: sans-serif; }
    #controls { margin-bottom: 1em; }
    .slider-group { margin-bottom: 0.5em; }
  </style>
</head>
<body>
  <div id="controls">
    <div class="slider-group">
      <label for="hueSpeed">Hue Shift Speed: <span id="hueSpeedVal">1</span>Â°/frame</label><br>
      <input id="hueSpeed" type="range" min="0" max="10" step="0.01" value="1">
    </div>
    <div class="slider-group">
      <label for="captureFPS">Capture Rate: <span id="fpsVal">30</span> fps</label><br>
      <input id="captureFPS" type="range" min="1" max="60" value="30">
    </div>
    <div class="slider-group">
      <label for="blendMode">Blend Mode: <span id="blendModeVal">screen</span></label><br>
      <select id="blendMode">
        <option value="screen">Screen</option>
        <option value="lighter">Add (lighter)</option>
        <option value="multiply">Multiply</option>
      </select>
    </div>
    <div class="slider-group">
      <label for="brightness">Brightness: <span id="brightnessVal">1.0</span></label><br>
      <input id="brightness" type="range" min="0" max="2" step="0.01" value="1">
    </div>
    <div class="slider-group">
      <label for="contrast">Contrast: <span id="contrastVal">1.0</span></label><br>
      <input id="contrast" type="range" min="0" max="3" step="0.01" value="1">
    </div>
  </div>
  <video id="video" playsinline autoplay style="display:none;"></video>
  <canvas id="output"></canvas>
  <script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('output');
    const ctx = canvas.getContext('2d');
    let width = 640, height = 480;

    // Settings
    let hueShift = 0;
    let hueShiftSpeed = 1;
    let captureFPS = 30;
    let lastCaptureTime = 0;
    let blendMode = 'screen';
    const buffer = []; // stores off-screen canvases
    const maxBuffer = 30;
    let brightness = 1.0;
    let contrast = 1.0;

    // UI controls
    const hueSpeedEl = document.getElementById('hueSpeed');
    const hueSpeedVal = document.getElementById('hueSpeedVal');
    hueSpeedEl.addEventListener('input', e => {
      hueShiftSpeed = parseFloat(e.target.value);
      hueSpeedVal.textContent = hueShiftSpeed;
    });
    hueShiftSpeed = parseFloat(hueSpeedEl.value);
    hueSpeedVal.textContent = hueShiftSpeed;

    const fpsEl = document.getElementById('captureFPS');
    const fpsVal = document.getElementById('fpsVal');
    fpsEl.addEventListener('input', e => {
      captureFPS = parseInt(e.target.value);
      fpsVal.textContent = captureFPS;
    });
    captureFPS = parseInt(fpsEl.value);
    fpsVal.textContent = captureFPS;

    const blendModeEl = document.getElementById('blendMode');
    const blendModeVal = document.getElementById('blendModeVal');
    blendModeEl.addEventListener('input', e => {
      blendMode = e.target.value;
      blendModeVal.textContent = blendMode;
    });
    blendMode = blendModeEl.value;
    blendModeVal.textContent = blendMode;

    const brightnessEl = document.getElementById('brightness');
    const brightnessVal = document.getElementById('brightnessVal');
    const contrastEl = document.getElementById('contrast');
    const contrastVal = document.getElementById('contrastVal');
    brightnessEl.addEventListener('input', e => {
      brightness = parseFloat(e.target.value);
      brightnessVal.textContent = brightness.toFixed(2);
    });
    brightness = parseFloat(brightnessEl.value);
    brightnessVal.textContent = brightness.toFixed(2);
    contrastEl.addEventListener('input', e => {
      contrast = parseFloat(e.target.value);
      contrastVal.textContent = contrast.toFixed(2);
    });
    contrast = parseFloat(contrastEl.value);
    contrastVal.textContent = contrast.toFixed(2);

    // Camera setup
    async function startCamera() {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'user', width: {ideal: 640}, height: {ideal: 480} },
        audio: false
      });
      video.srcObject = stream;
      return new Promise(res => video.onloadedmetadata = res);
    }

    function hueShiftImageData(imageData, degree) {
      // shift hue for each pixel (naive, not super performant for big canvas)
      const d = imageData.data;
      for (let i = 0; i < d.length; i += 4) {
        let r = d[i] / 255, g = d[i+1] / 255, b = d[i+2] / 255;
        let max = Math.max(r,g,b), min = Math.min(r,g,b);
        let h, s, v = max;
        let dlt = max - min;
        s = max === 0 ? 0 : dlt / max;
        if(max === min) h = 0;
        else {
          switch(max) {
            case r: h = (g-b)/dlt + (g<b?6:0); break;
            case g: h = (b-r)/dlt + 2; break;
            case b: h = (r-g)/dlt + 4; break;
          }
          h /= 6;
        }
        // shift hue
        h = (h + degree/360) % 1;
        // convert back to RGB
        let q = v < 0.5 ? v * (1+s) : v + s - v*s;
        let p = 2 * v - q;
        let f = n => {
          n = (n+1)%1;
          if (n < 1/6) return p + (q-p)*6*n;
          if (n < 0.5) return q;
          if (n < 2/3) return p + (q-p)*(2/3-n)*6;
          return p;
        };
        r = f(h);
        g = f(h-1/3);
        b = f(h-2/3);
        d[i] = Math.max(0,Math.min(255,Math.round(r*255)));
        d[i+1] = Math.max(0,Math.min(255,Math.round(g*255)));
        d[i+2] = Math.max(0,Math.min(255,Math.round(b*255)));
      }
      return imageData;
    }

    function applyBrightnessContrast(imageData, brightness, contrast) {
      // contrast: 1=no change; brightness: 1=no change
      const d = imageData.data;
      // contrast algorithm: https://stackoverflow.com/a/56678483
      let c = contrast;
      let b = brightness;
      for (let i = 0; i < d.length; i += 4) {
        // Brightness
        d[i] = Math.max(0, Math.min(255, d[i] * b));
        d[i+1] = Math.max(0, Math.min(255, d[i+1] * b));
        d[i+2] = Math.max(0, Math.min(255, d[i+2] * b));
        // Contrast
        d[i] = Math.max(0, Math.min(255, ((d[i] - 128) * c + 128)));
        d[i+1] = Math.max(0, Math.min(255, ((d[i+1] - 128) * c + 128)));
        d[i+2] = Math.max(0, Math.min(255, ((d[i+2] - 128) * c + 128)));
      }
      return imageData;
    }
    function removeWhites(imageData, threshold=250) {
      // Set alpha to 0 if all rgb > threshold
      const d = imageData.data;
      for (let i = 0; i < d.length; i += 4) {
        if (d[i] > threshold && d[i+1] > threshold && d[i+2] > threshold) {
          d[i+3] = 0;
        }
      }
      return imageData;
    }

    function hueShiftCanvas(srcCanvas, degree, outputDataModifiers=[]) {
      const ctx2 = srcCanvas.getContext('2d');
      let imageData = ctx2.getImageData(0, 0, srcCanvas.width, srcCanvas.height);
      hueShiftImageData(imageData, degree);
      // extra processing like brightness/contrast
      for (const mod of outputDataModifiers) imageData = mod(imageData);
      ctx2.putImageData(imageData, 0, 0);
    }

    function renderBlendedBuffer() {
      ctx.clearRect(0,0,width,height);
      for(let i = 0; i < buffer.length; ++i) {
        ctx.globalCompositeOperation = blendMode;
        if(blendMode === 'screen') {
          // For screen, filter out pure/near-white pixels for this frame
          let tmp = document.createElement('canvas');
          tmp.width = width; tmp.height = height;
          let tctx = tmp.getContext('2d');
          tctx.drawImage(buffer[i], 0, 0);
          let id = tctx.getImageData(0, 0, width, height);
          removeWhites(id, 245);
          tctx.putImageData(id, 0, 0);
          ctx.drawImage(tmp, 0, 0);
        } else {
          ctx.drawImage(buffer[i], 0, 0);
        }
      }
      ctx.globalCompositeOperation = 'source-over';
    }

    function tick(now) {
      requestAnimationFrame(tick);
      if(now-lastCaptureTime < 1000/captureFPS) return;
      lastCaptureTime = now;
      const tmp = document.createElement('canvas');
      tmp.width = width; tmp.height = height;
      const tctx = tmp.getContext('2d');
      tctx.drawImage(video, 0, 0, width, height);
      hueShift = (hueShift + hueShiftSpeed) % 360;
      // process pipeline: hue, brightness, contrast
      hueShiftCanvas(tmp, hueShift, [
        img => applyBrightnessContrast(img, brightness, contrast)
      ]);
      buffer.push(tmp);
      if(buffer.length > maxBuffer) buffer.shift();
      renderBlendedBuffer();
    }

    startCamera().then(() => {
      width = video.videoWidth || 640;
      height = video.videoHeight || 480;
      canvas.width = width;
      canvas.height = height;
      lastCaptureTime = performance.now();
      requestAnimationFrame(tick);
    });
  </script>
</body>
</html>
