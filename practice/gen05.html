<!DOCTYPE html>

<html>

<head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: black;
    }
  </style>
</head>

<body>
  <script>
    let particles = [];
    let attractors = [];
    let distanceGrid = [];
    let gridResolution = 5; // pixels per grid cell

    function setup() {
      createCanvas(windowWidth, windowHeight);
      colorMode(HSB, 360, 100, 100, 100);
      // blendMode(ADD);

      // Create attractors for each letter
      let startX = width / 2 - 300;
      let y = height / 2;
      let spacing = 100;

      // G
      createG(startX, y);
      // E
      createE(startX + spacing, y);
      // N
      createN(startX + spacing * 2, y);
      // U
      createU(startX + spacing * 3, y);
      // A
      createAprime(startX + spacing * 4, y);
      // R
      createR(startX + spacing * 5, y);
      // Y
      createY(startX + spacing * 6, y);

      // Build distance grid cache
      buildDistanceGrid();

      // Create particles
      for (let i = 0; i < 1000; i++) {
        particles.push(new Particle());
      }
    }

    function draw() {
      background(0, 0, 0, 1);



      for (let p of particles) {
        p.applyForces();
        p.update();
        p.display();
      }

      // Debug: draw red dots at attractor locations
      // noStroke();
      // fill(0, 0, 0);
      // for (let a of attractors) {
      //   circle(a.x, a.y, 6);
      // }
    }

    class Particle {
      constructor() {
        this.pos = createVector(random(width), random(height));
        this.vel = createVector(0, 0);
        this.acc = createVector(0, 0);
        this.maxSpeed = 4;
        this.maxForce = 0.3;
      }

      applyForces() {
        let closest = null;
        let minDist = Infinity;


        for (let a of attractors) {
          let d = p5.Vector.dist(this.pos, a);
          if (d < minDist) {
            minDist = d;
            closest = a;
          }
        }

        if (closest) {
          let force = p5.Vector.sub(closest, this.pos);
          let d = force.mag();

          if (d < 5) {
            force.mult(-1);
            force.setMag(this.maxForce * 2);
          } else if (d < 100) {
            force.setMag(map(d, 0, 100, 0, this.maxForce));
          } else {
            force.setMag(0);
          }

          this.acc.add(force);
        }

        // Mouse repulsion
        let mousePos = createVector(mouseX, mouseY);
        let mouseForce = p5.Vector.sub(this.pos, mousePos); // Force away from mouse
        let mouseDist = mouseForce.mag();

        if (mouseDist < 100 && mouseDist > 0) {
          // Normalize and scale by inverse distance (stronger when closer)
          mouseForce.normalize();
          let intensity = map(mouseDist, 0, 100, this.maxForce * 3, 0); // Strong repulsion when close
          mouseForce.mult(intensity);
          this.acc.add(mouseForce);
        }


      }

      update() {
        this.vel.add(this.acc);
        this.vel.limit(this.maxSpeed);
        this.pos.add(this.vel);
        this.acc.mult(0);

        // Wrap around
        if (this.pos.x < 0) this.pos.x = width;
        if (this.pos.x > width) this.pos.x = 0;
        if (this.pos.y < 0) this.pos.y = height;
        if (this.pos.y > height) this.pos.y = 0;
      }

      display() {
        noStroke();

        // Use cached distance to closest attractor
        let minDist = getCachedDistance(this.pos.x, this.pos.y);

        // Map distance to hue: red (0) when close, cyan (180) when far, using log scale
        let logMin = 0; // log(1)
        let logMax = Math.log(100 + 1); // log(101)
        let logDist = Math.log(minDist + 1);
        let hue = map(logDist, logMin, logMax, 0, 180);
        hue = constrain(hue, 0, 180);

        // Calculate brightness based on distance AND velocity
        let velocityMagnitude = this.vel.mag();
        let distanceBrightness = map(minDist, 0, 100, 100, 20); // Higher when closer
        let velocityBrightness = 0; //map(velocityMagnitude, 0, this.maxSpeed, 30, 100); // Higher when faster

        // Combine distance and velocity brightness
        let combinedBrightness = (distanceBrightness + velocityBrightness);// / 2;
        combinedBrightness = constrain(combinedBrightness, 20, 255);

        fill(hue, 90, combinedBrightness);
        circle(this.pos.x, this.pos.y, 2);
      }
    }

    function createG(x, y) {
      // Vertical left
      for (let i = 0; i <= 20; i++) attractors.push(createVector(x - 20, y - 30 + i * 3));
      // Top curve
      for (let a = PI; a <= TWO_PI; a += 0.1) attractors.push(createVector(x + cos(a) * 20, y - 30 + sin(a) * 20));
      // Bottom curve
      for (let a = 0; a <= PI; a += 0.1) attractors.push(createVector(x + cos(a) * 20, y + 30 + sin(a) * 20));
      // Horizontal middle right
      for (let i = 0; i <= 10; i++) attractors.push(createVector(x + 10 + i * 2, y + 0));
      // vertical right
      for (let i = 0; i <= 10; i++) attractors.push(createVector(x + 20, y + 0 + i * 3));
    }

    function createE(x, y) {
      // Vertical
      for (let i = 0; i <= 20; i++) attractors.push(createVector(x, y - 30 + i * 3));
      // Top horizontal
      for (let i = 0; i <= 10; i++) attractors.push(createVector(x + i * 2, y - 30));
      // Middle horizontal
      for (let i = 0; i <= 8; i++) attractors.push(createVector(x + i * 2, y));
      // Bottom horizontal
      for (let i = 0; i <= 10; i++) attractors.push(createVector(x + i * 2, y + 30));
    }

    function createN(x, y) {
      // Left vertical
      for (let i = 0; i <= 20; i++) attractors.push(createVector(x - 10, y - 30 + i * 3));
      // Diagonal
      for (let i = 0; i <= 20; i++) attractors.push(createVector(x - 10 + i, y - 30 + i * 3));
      // Right vertical
      for (let i = 0; i <= 20; i++) attractors.push(createVector(x + 10, y - 30 + i * 3));
    }

    function createU(x, y) {
      // Left vertical
      for (let i = 0; i <= 15; i++) attractors.push(createVector(x - 15, y - 30 + i * 3));
      // Bottom curve
      for (let a = 0; a <= PI; a += 0.1) attractors.push(createVector(x + cos(a) * 15, y + 15 + sin(a) * 15));
      // Right vertical
      for (let i = 0; i <= 15; i++) attractors.push(createVector(x + 15, y - 30 + i * 3));
    }

    function createAprime(x, y) {
      // Left diagonal
      for (let i = 0; i <= 20; i++) attractors.push(createVector(x - 20 + i * 1, y + 30 - i * 3));
      // Right diagonal
      for (let i = 0; i <= 20; i++) attractors.push(createVector(x + 20 - i * 1, y + 30 - i * 3));
      // Crossbar
      for (let i = 0; i <= 10; i++) attractors.push(createVector(x - 5 + i, y));
    }

    function createR(x, y) {
      // Vertical
      for (let i = 0; i <= 20; i++) attractors.push(createVector(x - 10, y - 30 + i * 3));
      // Top curve
      for (let a = -HALF_PI; a <= HALF_PI; a += 0.1) attractors.push(createVector(x + cos(a) * 12, y - 15 + sin(a) * 12));
      // Diagonal leg
      for (let i = 0; i <= 15; i++) attractors.push(createVector(x + i * 1.2, y + i * 2));
    }

    function createY(x, y) {
      // Top left diagonal
      for (let i = 0; i <= 10; i++) attractors.push(createVector(x - 15 + i * 1.5, y - 30 + i * 3));
      // Top right diagonal
      for (let i = 0; i <= 10; i++) attractors.push(createVector(x + 15 - i * 1.5, y - 30 + i * 3));
      // Bottom vertical
      for (let i = 0; i <= 10; i++) attractors.push(createVector(x, y + i * 3));
    }

    function buildDistanceGrid() {
      distanceGrid = [];
      let cols = Math.ceil(width / gridResolution) + 1;
      let rows = Math.ceil(height / gridResolution) + 1;

      for (let i = 0; i < cols; i++) {
        distanceGrid[i] = [];
        for (let j = 0; j < rows; j++) {
          let x = i * gridResolution;
          let y = j * gridResolution;
          let minDist = Infinity;

          for (let a of attractors) {
            let d = dist(x, y, a.x, a.y);
            if (d < minDist) minDist = d;
          }

          distanceGrid[i][j] = minDist;
        }
      }
    }

    function getCachedDistance(x, y) {
      let i = Math.floor(x / gridResolution);
      let j = Math.floor(y / gridResolution);

      // Clamp to grid bounds
      i = constrain(i, 0, distanceGrid.length - 1);
      j = constrain(j, 0, distanceGrid[0].length - 1);

      return distanceGrid[i][j];
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      buildDistanceGrid(); // Rebuild grid on resize
    }
  </script>

</body>

</html>