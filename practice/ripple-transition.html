<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Liquid Wave Transition</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #111;
            font-family: sans-serif;
        }

        /* Container for the effect */
        .slider-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Canvas container */
        .canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Dot container and dots */
        #dotContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .pointer-dot {
            position: absolute;
            width: 4px;
            height: 4px;
            background: red;
            border-radius: 50%;
            pointer-events: none;
        }

        /* Draw toggle */
        .draw-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            user-select: none;
        }

        .draw-toggle input {
            margin-right: 8px;
        }

        /* Hint text */
        .hint {
            position: absolute;
            bottom: 30px;
            color: white;
            z-index: 10;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 20px;
            pointer-events: none;
            user-select: none;
        }
    </style>
</head>
<body>

    <div class="canvas-container">
        <canvas id="rippleCanvas"></canvas>
        <div id="dotContainer"></div>
    </div>

    <div class="hint">Drag to create ripples or scroll wheel to cycle through images</div>

    <label class="draw-toggle">
        <input type="checkbox" id="drawDots"> Draw pointer trail
    </label>

    <script>
        console.log('üé¨ WebGL Ripple transition starting...');

        // Array of random background images
        const imageUrls = [
            'https://images.unsplash.com/photo-1493166228553-4fa0fdb916e8?q=80&w=2000&auto=format&fit=crop',
            'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?q=80&w=2000&auto=format&fit=crop',
            'https://images.unsplash.com/photo-1441974231531-c6227db76b6e?q=80&w=2000&auto=format&fit=crop',
            'https://images.unsplash.com/photo-1418065460487-3e41a6c84dc5?q=80&w=2000&auto=format&fit=crop',
            'https://images.unsplash.com/photo-1469474968028-56623f02e42e?q=80&w=2000&auto=format&fit=crop',
            'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?q=80&w=2000&auto=format&fit=crop',
            'https://images.unsplash.com/photo-1447752875215-b2761acb3c5d?q=80&w=2000&auto=format&fit=crop'
        ];

        // WebGL variables
        let canvas, gl, program;
        let textures = [];
        let time = 0;

        // Image cycling
        let currentBgIndex = 0;
        let currentFgIndex = 1;
        let transitionProgress = 0;

        // Ripple state
        const ripples = [];
        let rippleId = 0;
        let isDragging = false;

        // Mouse state
        const mouseState = {
            x: 0.5,
            y: 0.5,
            prevX: 0.5,
            prevY: 0.5
        };

        // Drawing state
        let drawDotsEnabled = false;

        // Initialize WebGL
        function initWebGL() {
            console.log('üîß Initializing WebGL...');
            canvas = document.getElementById('rippleCanvas');
            if (!canvas) {
                console.error('‚ùå Canvas element not found!');
                return false;
            }

            // Get WebGL context
            gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (!gl) {
                console.error('‚ùå WebGL not supported!');
                return false;
            }

            console.log('‚úÖ WebGL initialized');
            return true;
        }

        // Resize canvas
        function resizeCanvas() {
            const pixelRatio = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * pixelRatio;
            canvas.height = window.innerHeight * pixelRatio;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            gl.viewport(0, 0, canvas.width, canvas.height);
            console.log('üìê Canvas resized:', canvas.width, 'x', canvas.height);
        }

        // Load texture from image URL
        function loadTexture(url) {
            return new Promise((resolve, reject) => {
                const texture = gl.createTexture();
                const image = new Image();

                image.crossOrigin = 'anonymous';
                image.onload = () => {
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                    console.log('üñºÔ∏è Texture loaded:', url);
                    resolve(texture);
                };

                image.onerror = () => {
                    console.error('‚ùå Failed to load texture:', url);
                    reject(new Error('Failed to load texture'));
                };

                image.src = url;
            });
        }

        // Create shader
        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('‚ùå Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        // Create shader program
        function createProgram(vertexSource, fragmentSource) {
            const vertexShader = createShader(gl.VERTEX_SHADER, vertexSource);
            const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentSource);

            if (!vertexShader || !fragmentShader) {
                return null;
            }

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('‚ùå Program linking error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }

            return program;
        }

        // Initialize the effect
        async function init() {
            if (!initWebGL()) return;

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Load 3 images for cycling
            const selectedUrls = [];
            while (selectedUrls.length < 3) {
                const url = imageUrls[Math.floor(Math.random() * imageUrls.length)];
                if (!selectedUrls.includes(url)) {
                    selectedUrls.push(url);
                }
            }

            console.log('üì∏ Loading 3 textures for cycling...');
            try {
                textures = await Promise.all(selectedUrls.map(url => loadTexture(url)));
                console.log('‚úÖ All textures loaded successfully');
            } catch (error) {
                console.error('‚ùå Failed to load textures:', error);
                return;
            }

            // Create shader program
            const vertexShaderSource = `
                attribute vec2 a_position;
                attribute vec2 a_texCoord;
                varying vec2 v_texCoord;

                void main() {
                    gl_Position = vec4(a_position, 0.0, 1.0);
                    v_texCoord = a_texCoord;
                }
            `;

            const fragmentShaderSource = `
                precision mediump float;

                uniform sampler2D u_texture1;
                uniform sampler2D u_texture2;
                uniform float u_time;
                uniform vec2 u_resolution;
                uniform vec2 u_mouse;
                uniform vec4 u_ripples[15]; // x, y, radius, active (1.0 or 0.0)
                uniform int u_rippleCount;

                varying vec2 v_texCoord;

                // Noise function for liquid distortion
                vec2 hash2(vec2 p) {
                    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));
                    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
                }

                float noise(vec2 p) {
                    const float K1 = 0.366025404; // (sqrt(3)-1)/2;
                    const float K2 = 0.211324865; // (3-sqrt(3))/6;
                    vec2 i = floor(p + (p.x + p.y) * K1);
                    vec2 a = p - i + (i.x + i.y) * K2;
                    float m = step(a.y, a.x);
                    vec2 o = vec2(m, 1.0 - m);
                    vec2 b = a - o + K2;
                    vec2 c = a - 1.0 + 2.0 * K2;
                    vec3 h = max(0.5 - vec3(dot(a,a), dot(b,b), dot(c,c)), 0.0);
                    vec3 n = h * h * h * h * vec3(dot(a, hash2(i + 0.0)), dot(b, hash2(i + o)), dot(c, hash2(i + 1.0)));
                    return dot(n, vec3(70.0));
                }

                void main() {
                    vec2 uv = v_texCoord;
                    vec2 st = uv * u_resolution;

                    // Calculate distance from mouse for distortion
                    float dist = distance(uv, u_mouse);
                    float distortionStrength = 0.0;

                    // Check all ripples
                    for (int i = 0; i < 15; i++) {
                        vec4 ripple = u_ripples[i];
                        if (ripple.w < 0.5) continue; // Not active

                        vec2 ripplePos = ripple.xy;
                        float rippleRadius = ripple.z;

                        float rippleDist = distance(uv, ripplePos);
                        if (rippleDist < rippleRadius) {
                            // Inside ripple - reveal foreground
                            distortionStrength += (1.0 - rippleDist / rippleRadius) * 0.5;
                        }
                    }

                    // Apply liquid distortion
                    vec2 noiseUV = uv * 3.0 + u_time * 0.1;
                    vec2 distortion = vec2(
                        noise(noiseUV),
                        noise(noiseUV + vec2(100.0, 100.0))
                    ) * distortionStrength * 0.02;

                    vec2 distortedUV = uv + distortion;

                    // Sample both textures
                    vec4 bgColor = texture2D(u_texture1, distortedUV);
                    vec4 fgColor = texture2D(u_texture2, distortedUV);

                    // Create mask from ripples
                    float mask = 0.0;
                    for (int i = 0; i < 15; i++) {
                        vec4 ripple = u_ripples[i];
                        if (ripple.w < 0.5) continue; // Not active

                        vec2 ripplePos = ripple.xy;
                        float rippleRadius = ripple.z;

                        float rippleDist = distance(uv, ripplePos);
                        if (rippleDist < rippleRadius) {
                            mask = max(mask, 1.0 - rippleDist / rippleRadius);
                        }
                    }

                    // Blend colors based on mask
                    vec4 finalColor = mix(bgColor, fgColor, mask);

                    gl_FragColor = finalColor;
                }
            `;

            program = createProgram(vertexShaderSource, fragmentShaderSource);
            if (!program) {
                console.error('‚ùå Failed to create shader program');
                return;
            }

            gl.useProgram(program);

            // Create quad geometry
            const positions = new Float32Array([
                -1, -1,
                 1, -1,
                -1,  1,
                 1,  1,
            ]);

            const texCoords = new Float32Array([
                0, 1,
                1, 1,
                0, 0,
                1, 0,
            ]);

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

            const positionLocation = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            const texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);

            const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
            gl.enableVertexAttribArray(texCoordLocation);
            gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

            // Set up uniforms
            const texture1Location = gl.getUniformLocation(program, 'u_texture1');
            const texture2Location = gl.getUniformLocation(program, 'u_texture2');
            const timeLocation = gl.getUniformLocation(program, 'u_time');
            const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
            const mouseLocation = gl.getUniformLocation(program, 'u_mouse');
            const ripplesLocation = gl.getUniformLocation(program, 'u_ripples');
            const rippleCountLocation = gl.getUniformLocation(program, 'u_rippleCount');

            // Store uniform locations for animation loop
            program.uniforms = {
                texture1: texture1Location,
                texture2: texture2Location,
                time: timeLocation,
                resolution: resolutionLocation,
                mouse: mouseLocation,
                ripples: ripplesLocation,
                rippleCount: rippleCountLocation
            };

            console.log('‚úÖ WebGL setup complete');

            console.log('‚úÖ WebGL setup complete');

            // Set up event listeners
            setupEventListeners();

            // Start animation
            animate();
        }

        // Set up mouse/touch event listeners
        function setupEventListeners() {
            console.log('üéß Setting up event listeners...');

            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                updateMousePosition(e);
                createRipple();
            });

            canvas.addEventListener('mousemove', (e) => {
                updateMousePosition(e);
                if (isDragging) {
                    createRipple();
                }
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });

            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isDragging = true;
                updateMousePosition(e.touches[0]);
                createRipple();
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                updateMousePosition(e.touches[0]);
                if (isDragging) {
                    createRipple();
                }
            });

            canvas.addEventListener('touchend', () => {
                isDragging = false;
            });

            // Mouse wheel for image transitions
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                performImageTransition();
            });

            // Checkbox for drawing dots
            const drawCheckbox = document.getElementById('drawDots');
            if (drawCheckbox) {
                drawCheckbox.addEventListener('change', (e) => {
                    drawDotsEnabled = e.target.checked;
                    if (!drawDotsEnabled) {
                        clearDots();
                    }
                });
            }

            console.log('‚úÖ Event listeners set up');
        }


        // Create a new ripple
        function createRipple() {
            const ripple = {
                id: rippleId++,
                x: mouseState.x,
                y: mouseState.y,
                radius: 0,
                maxRadius: 1.5, // Relative to screen size
                speed: 1.0,
                created: time
            };

            ripples.push(ripple);

            // Limit ripple count
            if (ripples.length > 15) {
                ripples.shift();
            }

            console.log('üí´ Ripple created:', ripple);
        }

        // Animation loop
        function animate() {
            time += 0.016; // ~60fps

            // Update ripples
            ripples.forEach((ripple, index) => {
                const age = time - ripple.created;
                const progress = Math.min(age * ripple.speed, 1);

                ripple.radius = ripple.maxRadius * easeOutQuad(progress);

                // Remove completed ripples
                if (progress >= 1) {
                    ripples.splice(index, 1);
                }
            });

            // Check if we should transition to next image
            // Transition when there are no active ripples and some time has passed
            if (ripples.length === 0) {
                transitionProgress += 0.016;
                if (transitionProgress > 2.0) { // Wait 2 seconds after ripples complete
                    performImageTransition();
                }
            } else {
                transitionProgress = 0;
            }

            // Render
            render();

            requestAnimationFrame(animate);
        }

        // Perform image transition
        function performImageTransition() {
            console.log('üîÑ Performing image transition');

            // Move background to current foreground, foreground to next image
            currentBgIndex = currentFgIndex;
            currentFgIndex = (currentFgIndex + 1) % textures.length;

            console.log(`üì∏ Images: BG=${currentBgIndex}, FG=${currentFgIndex}`);
        }

        // Render function
        function render() {
            gl.clear(gl.COLOR_BUFFER_BIT);

            if (!program) return;

            gl.useProgram(program);

            // Bind current textures
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textures[currentBgIndex]);
            gl.uniform1i(program.uniforms.texture1, 0);

            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, textures[currentFgIndex]);
            gl.uniform1i(program.uniforms.texture2, 1);

            // Update uniforms
            gl.uniform1f(program.uniforms.time, time);
            gl.uniform2f(program.uniforms.resolution, canvas.width, canvas.height);
            gl.uniform2f(program.uniforms.mouse, mouseState.x, mouseState.y);

            // Pack ripples into uniform array (vec4: x, y, radius, active)
            const rippleData = [];
            for (let i = 0; i < 15; i++) {
                if (i < ripples.length) {
                    const ripple = ripples[i];
                    rippleData.push(ripple.x, ripple.y, ripple.radius, 1.0); // active
                } else {
                    rippleData.push(0, 0, 0, 0); // inactive
                }
            }

            gl.uniform4fv(program.uniforms.ripples, rippleData);
            gl.uniform1i(program.uniforms.rippleCount, Math.min(ripples.length, 15));

            // Draw
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        // Easing function
        function easeOutQuad(t) {
            return t * (2 - t);
        }

        // Start the application
        init().catch(console.error);

        function startDrag(e) {
            // console.log('üëÜ Drag started', e.type, { clientX: e.clientX, clientY: e.clientY });
            isDragging = true;
            updateMousePosition(e);
            drawDot(mouseState.x, mouseState.y);
            createRipple();
        }

        function handleMove(e) {
            if (isDragging) {
                // console.log('üëÜ Drag move', { clientX: e.clientX, clientY: e.clientY });
                updateMousePosition(e);
                drawDot(mouseState.x, mouseState.y);
                createRipple();
            }
        }

        function endDrag() {
            // console.log('üëÜ Drag ended');
            isDragging = false;
            clearDots();
        }

        function updateMousePosition(e) {
            const oldX = mouseState.x;
            const oldY = mouseState.y;
            mouseState.prevX = oldX;
            mouseState.prevY = oldY;
            mouseState.x = e.clientX / window.innerWidth;
            mouseState.y = e.clientY / window.innerHeight; // Keep Y coordinate as-is
            // console.log('üìç Mouse position updated:', {
            //     from: { x: oldX, y: oldY },
            //     to: { x: mouseState.x, y: mouseState.y }
            // });
        }

        // Draw dot at current mouse position
        function drawDot(x, y) {
            if (!drawDotsEnabled) return;

            const dot = document.createElement('div');
            dot.className = 'pointer-dot';
            dot.style.left = (x * 100) + '%';
            dot.style.top = (y * 100) + '%';

            const container = document.getElementById('dotContainer');
            container.appendChild(dot);
        }

        // Clear all dots
        function clearDots() {
            const container = document.getElementById('dotContainer');
            container.innerHTML = '';
        }

        function createRipple() {
            const ripple = {
                id: rippleId++,
                x: mouseState.x,
                y: mouseState.y,
                radius: 0,
                maxRadius: 1.5, // Maximum expansion distance (normalized)
                speed: 1.0,
                created: time
            };

            ripples.push(ripple);
            // console.log('üí´ Ripple created:', ripple);

            // Limit number of active ripples for performance
            if (ripples.length > 20) {
                const removed = ripples.shift();
                // console.log('üóëÔ∏è Removed old ripple:', removed.id);
            }

            // console.log('üìä Active ripples count:', ripples.length);
        }


        // Easing function for smooth ripple expansion
        function easeOutQuad(t) {
            return t * (2 - t);
        }

        // console.log('üéâ Ripple transition script fully loaded and initialized!');
    </script>
</body>
</html>