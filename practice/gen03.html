<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Fibonacci Zoom</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden; /* Prevent scrollbars */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
        }
    </style>
</head>
<body>
<script>
    const PHI = (1 + Math.sqrt(5)) / 2; // The Golden Ratio
    let cells = [];

    function setup() {
        createCanvas(windowWidth, windowHeight);
        colorMode(HSB, 360, 100, 100, 1);
        rectMode(CENTER);
        noFill();
    }

    function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
    }

    function draw() {
        background(0);
        
        // Grid configuration: 2 columns, 3 rows
        let cols = 2;
        let rows = 3;
        let cellW = width / cols;
        let cellH = height / rows;

        // Draw the 6 patterns
        drawCell(0, 0, cellW, cellH, drawGoldenRects);
        drawCell(1, 0, cellW, cellH, drawPhyllotaxis);
        drawCell(0, 1, cellW, cellH, drawPentagons);
        drawCell(1, 1, cellW, cellH, drawTriangles);
        drawCell(0, 2, cellW, cellH, drawCircles);
        drawCell(1, 2, cellW, cellH, drawSpiralWeb);

        // Draw white borders for the grid
        stroke(255);
        strokeWeight(4);
        noFill();
        // Vertical line
        line(width/2, 0, width/2, height);
        // Horizontal lines
        line(0, height/3, width, height/3);
        line(0, (height/3)*2, width, (height/3)*2);
        // Outer border
        rect(width/2, height/2, width, height);
    }

    // Helper to setup clipping and translation for each cell
    function drawCell(col, row, w, h, drawFunc) {
        let x = col * w;
        let y = row * h;
        
        push();
        // Create clipping mask for this cell
        // We draw a rect and use drawingContext.clip() to keep graphics inside
        drawingContext.save();
        drawingContext.beginPath();
        drawingContext.rect(x, y, w, h);
        drawingContext.clip();

        // Translate to center of cell
        translate(x + w / 2, y + h / 2);
        
        // Pass the max dimension for scaling
        let maxDim = max(w, h);
        drawFunc(maxDim);

        drawingContext.restore();
        pop();
    }

    // --- PATTERN 1: Golden Rectangles Tunnel ---
    function drawGoldenRects(dim) {
        let time = millis() * 0.001; // Convert to seconds for smoother scaling
        let scaleFactor = pow(PHI, time * 0.1); // Exponential growth for infinite zoom

        rotate(time * 0.1); // Gentle rotation

        // Dynamic shape management: spawn new layers as we zoom out
        let baseLayers = 25;
        let dynamicLayers = floor(time * 2) + baseLayers; // Add new layers over time
        let maxVisibleSize = dim * 3; // Maximum size before culling

        for (let i = 0; i < dynamicLayers; i++) {
            let s = dim * 2 * pow(1/PHI, i) / scaleFactor; // Divide by scaleFactor to zoom out

            // Remove shapes that are too large
            if (s > maxVisibleSize) continue;
            // Stop drawing when shapes become too small to see
            if (s < 0.5) break;

            stroke(320, 60, 100);
            strokeWeight(max(1, 3 - i * 0.1)); // Thinner lines for outer layers
            rect(0, 0, s, s);

            // Draw the curve
            arc(-s/2, -s/2, s*2, s*2, 0, PI/2);
        }
    }

    // --- PATTERN 2: Phyllotaxis (Sunflower) Zoom ---
    function drawPhyllotaxis(dim) {
        let time = millis() / 1000;
        let cBase = 8;

        // For infinite zoom out, scale down over time exponentially
        let scaleMult = 1 / pow(PHI, time * 0.05); // Exponential decay for infinite zoom out

        scale(scaleMult);
        rotate(time * 0.2);

        let angle = 137.5; // Golden Angle

        // Dynamic dot management: increase dots over time, remove distant ones
        let baseDots = 200;
        let dynamicDots = baseDots + floor(time * 10); // Add more dots as time progresses
        let maxRadius = dim * 2 / scaleMult; // Maximum visible radius in scaled space

        for (let n = 0; n < dynamicDots; n++) {
            let r = cBase * sqrt(n);
            let theta = n * radians(angle);

            // Remove dots that are too far away
            if (r > maxRadius) break;

            let x = r * cos(theta);
            let y = r * sin(theta);

            // Color based on distance
            let hue = (n * 0.5 + time * 20) % 360;
            fill(hue, 70, 100);
            noStroke();
            let dotSize = max(0.5, (3 + n/20) * scaleMult); // Minimum size to prevent invisibility
            ellipse(x, y, dotSize, dotSize);
        }
    }

    // --- PATTERN 3: Nested Pentagons ---
    function drawPentagons(dim) {
        let time = millis() / 1000;
        // Infinite zoom out: exponential decay
        let currentScale = 1 / pow(PHI, time * 0.03);

        rotate(time * 0.2);

        noFill();
        stroke(200, 80, 100);
        strokeWeight(3);

        // Dynamic layer management: add new inner layers over time
        let baseLayers = 15;
        let dynamicLayers = baseLayers + floor(time * 1.5); // Gradually add more layers
        let radius = dim;

        scale(currentScale);

        for (let i = 0; i < dynamicLayers; i++) {
            // Stop drawing if pentagon becomes too small to see
            if (radius * currentScale < 1) break;

            drawPoly(0, 0, radius, 5);
            rotate(PI); // Alternate rotation for interest
            radius /= PHI;
            // Color gradient
            stroke((200 + i * 20) % 360, 80, 100);
            // Thinner lines for outer layers
            strokeWeight(max(1, 3 - i * 0.05));
        }
    }
    
    function drawPoly(x, y, radius, npoints) {
        let angle = TWO_PI / npoints;
        beginShape();
        for (let a = 0; a < TWO_PI; a += angle) {
            let sx = x + cos(a) * radius;
            let sy = y + sin(a) * radius;
            vertex(sx, sy);
        }
        endShape(CLOSE);
    }

    // --- PATTERN 4: Sierpinski / Golden Triangles ---
    function drawTriangles(dim) {
        let time = millis() / 1000;
        // Infinite zoom out: exponential decay
        let s = 1 / pow(PHI, time * 0.04);

        scale(s);
        rotate(time * 0.25);

        let h = dim * 1.5;

        strokeWeight(2);
        noFill();

        // Dynamic layer management: add more layers over time
        let baseLayers = 12;
        let dynamicLayers = baseLayers + floor(time * 2);

        for(let i=0; i<dynamicLayers; i++) {
            // Draw triangle
            let r = h / pow(1.5, i); // Factor 1.5 close to phi logic for triangles

            // Stop drawing if triangle becomes too small
            if (r * s < 2) break;

            stroke((40 + i*30)%360, 90, 100);
            strokeWeight(max(1, 2 - i * 0.05)); // Thinner lines for outer layers

            beginShape();
            for(let a=0; a<3; a++){
                let ang = TWO_PI/3 * a - PI/2;
                vertex(cos(ang)*r, sin(ang)*r);
            }
            endShape(CLOSE);

            // Rotate next iteration
            rotate(PI/6);
        }
    }

    // --- PATTERN 5: Concentric Circles (Tunnel) ---
    function drawCircles(dim) {
        let time = millis() / 1000;
        // Infinite zoom out using exponential scaling
        let zoomFactor = pow(PHI, time * 0.05);

        strokeWeight(2);
        noFill();

        // Dynamic ring management: add more rings over time
        let baseRings = 20;
        let dynamicRings = baseRings + floor(time * 3);

        for(let i = 0; i < dynamicRings; i++) {
            // Scale radius down exponentially over time
            let r = (dim/2) * pow(0.618, i) / zoomFactor;

            // Stop drawing rings that become too small
            if (r < 0.5) break;

            stroke((160 + i*20)%360, 80, 100);
            strokeWeight(max(1, 2 - i * 0.03)); // Thinner lines for outer rings

            // Add some waviness to the circles
            beginShape();
            for(let a=0; a<TWO_PI; a+=0.1){
                let offset = sin(a*10 + time * 2)* (r*0.05);
                vertex(cos(a)*(r+offset), sin(a)*(r+offset));
            }
            endShape(CLOSE);
        }
    }

    // --- PATTERN 6: Fibonacci Spiral Web ---
    function drawSpiralWeb(dim) {
        let time = millis() / 1000;
        // Rotate the whole web
        rotate(time * 0.2);

        // Infinite zoom out: exponential decay
        let zoom = 1 / pow(PHI, time * 0.025);
        scale(zoom);

        let arms = 8; // Fibonacci number

        // Dynamic ring management: add more rings over time
        let baseRings = 12;
        let dynamicRings = baseRings + floor(time * 2);

        strokeWeight(2);

        for (let i = 0; i < dynamicRings; i++) {
            let r = (dim) * pow(0.618, i - 1); // Exponential spacing

            // Stop drawing rings that become too small in scaled space
            if (r * zoom < 1) break;

            stroke((280 + i * 20) % 360, 70, 100);
            strokeWeight(max(1, 2 - i * 0.02)); // Thinner lines for outer rings

            beginShape();
            for (let j = 0; j <= arms * 3; j++) { // *3 for more detail in curve
                let theta = map(j, 0, arms, 0, TWO_PI);
                // Twist the radius based on angle to create spiral
                let rTwist = r * (1 + 0.3 * sin(theta * 5 + i + time));
                let x = rTwist * cos(theta + i*0.5); // Offset rotation per ring
                let y = rTwist * sin(theta + i*0.5);
                vertex(x, y);
            }
            endShape(CLOSE);
        }
    }
</script>
</body>
</html>