<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Audio-Reactive TSL Demo</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            z-index: 100;
        }

        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-family: monospace;
            z-index: 100;
        }

        #controls label {
            display: block;
            margin-bottom: 5px;
            cursor: pointer;
        }

        #controls input[type="checkbox"] {
            margin-right: 5px;
        }

        #eq {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .eq-column {
            display: flex;
            flex-direction: column-reverse;
            gap: 2px;
            width: 20px;
        }

        .eq-segment {
            height: 15px;
            background: #00ff00;
            border: 1px solid #000;
            transition: opacity 0.1s ease;
        }

        .eq-segment.yellow {
            background: #ffff00;
        }

        .eq-segment.red {
            background: #ff0000;
        }

        .eq-peak {
            position: absolute;
            width: 20px;
            height: 4px;
            background: #00ffff;
            transition: top 0.3s ease;
            pointer-events: none;
        }

        #startNote {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: monospace;
            font-size: 24px;
            text-align: center;
            z-index: 200;
            opacity: 0.7;
            transition: opacity 0.5s ease-out;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }

        #startNote.hidden {
            opacity: 0;
        }

        /* ImGui-style Control Panel */
        #imgui-panel {
            position: absolute;
            top: 10px;
            right: 200px;
            z-index: 100;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 11px;
            user-select: none;
        }

        .imgui-window {
            background: rgba(35, 35, 35, 0.95);
            border: 1px solid #555;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            min-width: 250px;
        }

        .imgui-title {
            background: #2d2d2d;
            color: #ffffff;
            padding: 6px 8px;
            border-bottom: 1px solid #555;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .imgui-title::after {
            content: "‚ñº";
            transition: transform 0.2s ease;
        }

        .imgui-window.collapsed .imgui-title::after {
            transform: rotate(-90deg);
        }

        .imgui-window.collapsed .imgui-content {
            display: none;
        }

        .imgui-content {
            padding: 8px;
        }

        .imgui-slider {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            color: #cccccc;
        }

        .imgui-slider label {
            flex: 1;
            margin-right: 8px;
            white-space: nowrap;
        }

        .imgui-slider input[type="range"] {
            flex: 2;
            margin-right: 8px;
            background: #444;
            border: 1px solid #666;
            border-radius: 2px;
            height: 16px;
            outline: none;
            -webkit-appearance: none;
        }

        .imgui-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 16px;
            background: #007acc;
            border-radius: 2px;
            cursor: pointer;
        }

        .imgui-slider input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 16px;
            background: #007acc;
            border-radius: 2px;
            cursor: pointer;
            border: none;
        }

        .imgui-slider span {
            min-width: 35px;
            text-align: right;
            color: #ffffff;
            font-family: monospace;
        }

        /* Audio Controls */
        #audioControls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(35, 35, 35, 0.95);
            border: 1px solid #555;
            border-radius: 4px;
            padding: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 12px;
            color: #cccccc;
            z-index: 100;
        }

        #audioControls button {
            background: #2d2d2d;
            border: 1px solid #555;
            color: #ffffff;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
        }

        #audioControls button:hover {
            background: #3d3d3d;
        }

        #audioControls input[type="range"] {
            background: #444;
            border: 1px solid #666;
            border-radius: 2px;
            height: 12px;
            outline: none;
        }

        #seekSlider {
            flex: 2;
            min-width: 200px;
        }

        #volumeSlider {
            width: 60px;
        }

        #audioControls span {
            color: #ffffff;
            font-family: monospace;
            min-width: 35px;
            text-align: center;
        }
    </style>
</head>

<body>
    <div id="info">Loading audio...</div>
    <div id="controls">
        <label>
            <input type="checkbox" id="wireframeToggle">
            Wireframe
        </label>
        <label style="position: absolute; left: 1000px;">
            Audio File:
            <input type="file" id="audioFileInput" accept="audio/*">
        </label>
    </div>

    <!-- Hidden HTML5 Audio Element -->
    <audio id="audioElement" controls style="display: none;"></audio>

    <!-- Audio Controls -->
    <div id="audioControls">
        <button id="playPauseBtn">‚ñ∂Ô∏è Play</button>
        <input type="range" id="seekSlider" min="0" max="100" value="0" step="0.1">
        <span id="currentTime">0:00</span> / <span id="duration">0:00</span>
        <input type="range" id="volumeSlider" min="0" max="1" value="0.5" step="0.01">
        <button id="uploadBtn">üìÅ Upload Audio</button>
    </div>

    <div id="eq">
        <div class="eq-column" id="bassColumn">
            <div class="eq-peak" id="bassPeak"></div>
        </div>
        <div class="eq-column" id="midColumn">
            <div class="eq-peak" id="midPeak"></div>
        </div>
        <div class="eq-column" id="highColumn">
            <div class="eq-peak" id="highPeak"></div>
        </div>
    </div>

    <div id="startNote">Click or tap to start</div>

    <!-- ImGui-style Control Panel -->
    <div id="imgui-panel">
        <div class="imgui-window">
            <div class="imgui-title">Controls</div>
            <div class="imgui-content">
                <div class="imgui-slider">
                    <label>Amplitude</label>
                    <input type="range" id="amplitudeSlider" min="0" max="1" step="0.01" value="0.3">
                    <span id="amplitudeValue">0.30</span>
                </div>
                <div class="imgui-slider">
                    <label>Noise Scale</label>
                    <input type="range" id="noiseScaleSlider" min="0.1" max="5" step="0.1" value="2.0">
                    <span id="noiseScaleValue">2.0</span>
                </div>
                <div class="imgui-slider">
                    <label>Noise Frequency</label>
                    <input type="range" id="noiseFreqSlider" min="0.1" max="3" step="0.1" value="1.0">
                    <span id="noiseFreqValue">1.0</span>
                </div>
                <div class="imgui-slider">
                    <label>Time Modulation</label>
                    <input type="range" id="timeModSlider" min="0.5" max="5" step="0.1" value="2.0">
                    <span id="timeModValue">2.0</span>
                </div>
                <div class="imgui-slider">
                    <label>Rotation Speed (¬∞/s)</label>
                    <input type="range" id="rotationSpeedSlider" min="-180" max="180" step="0.1" value="30.0">
                    <span id="rotationSpeedValue">30.0</span>
                </div>
                <div class="imgui-slider">
                    <label>Specularity</label>
                    <input type="range" id="specularitySlider" min="0" max="1" step="0.01" value="0.5">
                    <span id="specularityValue">0.5</span>
                </div>
                <div class="imgui-slider">
                    <label>Spike Base Offset</label>
                    <input type="range" id="spikeOffsetSlider" min="1.2" max="2.5" step="0.01" value="1.6">
                    <span id="spikeOffsetValue">1.6</span>
                </div>

                <!-- Bloom Controls Subsection (Disabled for now) -->
                <!-- <div style="border-top: 1px solid #555; margin: 8px 0; padding-top: 8px;">
                    <div style="color: #cccccc; font-size: 11px; margin-bottom: 6px; font-weight: bold;">Bloom Effects (WebGPU)</div>
                    <div style="color: #888; font-size: 10px; margin-bottom: 6px;">Coming soon with WebGPU shaders</div>
                </div> -->
            </div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.webgpu.js",
            "three/webgpu": "https://cdn.jsdelivr.net/npm/three@latest/build/three.webgpu.js",
            "three/tsl": "https://cdn.jsdelivr.net/npm/three@latest/build/three.tsl.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import {
            float, vec2, vec3, vec4, color, uniform, Fn,
            sin, cos, PI, mix, normalize, length,
            clamp,
            positionLocal, normalLocal, uv,
            positionWorld, normalWorld, cameraPosition,
            cameraViewMatrix, cameraProjectionMatrix, cameraWorldMatrix,
            modelWorldMatrix
        } from 'three/tsl';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let camera, scene, renderer, controls, specularity, spikeBaseOffset;
        let audioContext, audioSource, analyser, dataArray;
        let bassFilter, midFilter, highFilter;
        let bassUniform, midUniform, highUniform;
        let bassGain, midGain, highGain;
        let wobbleAmplitude, noiseScale, noiseFrequency, timeModulation, rotationSpeed;

        // Audio control variables
        let audioElement = null;
        let audioSourceNode = null;
        let masterGainNode = null;
        let audioInitialized = false;

        // Audio analysis values
        let bassLevel = 0;
        let midLevel = 0;
        let highLevel = 0;

        // EQ peak tracking
        let bassPeak = 0;
        let midPeak = 0;
        let highPeak = 0;
        const peakFallSpeed = 0.02;



        async function init() {
            // Setup renderer
            renderer = new THREE.WebGPURenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor('#000000');
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft shadows
            document.body.appendChild(renderer.domElement);
            await renderer.init();

            // For now, skip post-processing due to WebGPU compatibility issues
            // Will implement custom bloom shader later
            const composer = { render: () => renderer.render(scene, camera) };

            // Ensure the canvas can receive pointer events
            renderer.domElement.style.touchAction = 'none';
            renderer.domElement.style.position = 'fixed';
            renderer.domElement.style.top = '0';
            renderer.domElement.style.left = '0';
            renderer.domElement.style.width = '100%';
            renderer.domElement.style.height = '100%';
            renderer.domElement.style.zIndex = '1';

            // Setup scene
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 0, 8);

            // Setup audio
            await setupAudio();

            // Initialize controls after renderer and audio are ready
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enableZoom = true;
            controls.enablePan = true;
            controls.enableRotate = true;
            controls.minDistance = 3;
            controls.maxDistance = 30;
            controls.zoomSpeed = 1.0;
            controls.rotateSpeed = 0.5;

            // Setup EQ display
            setupEQ();

            // Create TSL materials
            bassUniform = uniform(0);
            midUniform = uniform(0);
            highUniform = uniform(0);
            const timeUniform = uniform(0);

            // Wobble control uniforms
            wobbleAmplitude = uniform(0.3);
            noiseScale = uniform(2.0);
            noiseFrequency = uniform(1.0);
            timeModulation = uniform(2.0);
            rotationSpeed = uniform(30.0); // Half degree per second
            specularity = uniform(0.5); // Specularity/metalness control (0-1)

            // Create normal material
            const normalMaterial = new THREE.MeshStandardMaterial({
                metalness: 0.5,
                roughness: 0.5
            });

            // Vertex shader - bass affects geometry distortion with camera awareness
            normalMaterial.vertexNode = Fn(() => {
                const pos = positionLocal;
                const time = timeUniform;

                // Apply Y-axis rotation based on time and rotation speed
                const rotationAngle = time.mul(rotationSpeed).mul(PI).div(180.0); // Convert degrees to radians
                const cosAngle = cos(rotationAngle);
                const sinAngle = sin(rotationAngle);
                const rotatedPos = vec3(
                    pos.x.mul(cosAngle).sub(pos.z.mul(sinAngle)),
                    pos.y,
                    pos.x.mul(sinAngle).add(pos.z.mul(cosAngle))
                );

                // Transform to world space
                const worldPos = modelWorldMatrix.mul(vec4(rotatedPos, 1.0)).xyz;

                // Create noise based on world position and time
                const noise1 = sin(worldPos.x.mul(noiseScale).add(time.mul(0.8).mul(noiseFrequency))).mul(cos(worldPos.y.mul(noiseScale).add(time.mul(1.2).mul(noiseFrequency))));
                const noise2 = sin(worldPos.z.mul(noiseScale).add(time.mul(0.6).mul(noiseFrequency))).mul(cos(worldPos.x.mul(noiseScale).add(time.mul(1.5).mul(noiseFrequency))));
                const noise = noise1.add(noise2).mul(0.5).add(0.5); // Normalize to 0-1

                // Get normal in world space for direction
                const worldNormal = normalize(modelWorldMatrix.mul(vec4(normalLocal, 0.0)).xyz);

                // Bass-driven displacement along normal direction with noise modulation
                const displacement = bassUniform
                    .mul(noise.mul(0.8).add(0.2)) // Mix noise with bass (0.2-1.0 range)
                    .mul(sin(time.mul(timeModulation).add(worldPos.x.add(worldPos.y).add(worldPos.z).mul(0.1))).mul(0.3).add(0.7)) // Additional time modulation
                    .mul(wobbleAmplitude); // Scale displacement

                // Apply displacement in world space
                const displacedWorldPos = worldPos.add(worldNormal.mul(displacement));

                // Transform back to view space for rendering
                const viewPos = cameraViewMatrix.mul(vec4(displacedWorldPos, 1.0));

                // Apply projection matrix to get clip space position
                const clipPos = cameraProjectionMatrix.mul(viewPos);

                return clipPos;
            })();

            // Fragment shader - gradient from top to bottom with independent hue offsets
            normalMaterial.colorNode = Fn(() => {
                const uvs = uv();
                const time = timeUniform;

                // Top color scheme (hue offset for top of sphere)
                const topColorShift = midUniform.mul(1.2).add(time.mul(0.8));
                const topBaseColor = vec3(
                    sin(topColorShift).mul(0.65).add(0.65), // Red channel
                    sin(topColorShift.mul(0.33)).mul(0.18).add(0.08), // Green channel - minimal
                    cos(topColorShift).mul(0.7).add(0.7) // Blue channel
                );

                // Bottom color scheme (different hue offset for bottom of sphere)
                const bottomColorShift = midUniform.mul(1.2).add(time.mul(0.8)).add(PI.mul(0.7)); // Offset hue by ~126 degrees
                const bottomBaseColor = vec3(
                    sin(bottomColorShift).mul(0.65).add(0.65), // Red channel
                    sin(bottomColorShift.mul(0.33)).mul(0.18).add(0.08), // Green channel - minimal
                    cos(bottomColorShift).mul(0.7).add(0.7) // Blue channel
                );

                // Interpolate between top and bottom colors based on vertical UV coordinate
                const baseColor = mix(topBaseColor, bottomBaseColor, uvs.y);

                // Bass adds deep red boost (applied to entire gradient)
                const bassColor = vec3(bassUniform.mul(0.9), 0.0, bassUniform.mul(0.1));

                // High adds bright blue highlights (applied to entire gradient)
                const highColor = vec3(highUniform.mul(0.25), highUniform.mul(0.12), highUniform.mul(0.6));

                // Mix colors, keep it saturated and vivid
                const finalColor = baseColor
                    .add(bassColor)
                    .add(highColor)
                    .mul(highUniform.mul(0.3).add(0.7)); // Brightness from high freq

                // Clamp color, since saturation could go over 1
                return vec4(clamp(finalColor, 0.0, 1.0), 1.0);
            })();

            // Create wireframe material (same shaders as normal material)
            const wireframeMaterial = new THREE.MeshStandardMaterial({
                wireframe: true,
                transparent: true,
                opacity: 0.6,
                metalness: 0.5,
                roughness: 0.5
            });

            // Apply the same shaders to wireframe material
            wireframeMaterial.vertexNode = normalMaterial.vertexNode;
            wireframeMaterial.colorNode = normalMaterial.colorNode;

            // Create sphere geometry
            const geometry = new THREE.SphereGeometry(1.5, 64, 64);
            const mesh = new THREE.Mesh(geometry, normalMaterial);
            mesh.receiveShadow = true; // Sphere receives shadows from spikes
            scene.add(mesh);

            // Create spikes container for rotation
            const spikesContainer = new THREE.Object3D();
            scene.add(spikesContainer);

            // Create spike geometry (cone shape)
            const spikeGeometry = new THREE.ConeGeometry(0.05, 0.8, 6);

            // Cube emission system
            const cubeGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const cubePool = [];
            const activeCubes = [];
            const CUBE_POOL_SIZE = 1000;
            const EMISSION_COOLDOWN = 300; // milliseconds
            let lastBassPeak = 0;
            let lastMidPeak = 0;
            let lastHighPeak = 0;

            // Function to create cube material based on emission direction
            const createCubeMaterial = (direction, useWireframe) => {
                // Use direction vector to create color variation
                const hue = (Math.atan2(direction.z, direction.x) + Math.PI) / (Math.PI * 2);
                const saturation = 0.8 + Math.abs(direction.y) * 0.2; // More saturated when vertical
                const lightness = 0.6 + Math.abs(direction.y) * 0.2; // Brighter when vertical

                // Convert HSL to RGB
                const c = (1 - Math.abs(2 * lightness - 1)) * saturation;
                const x = c * (1 - Math.abs((hue * 6) % 2 - 1));
                const m = lightness - c / 2;

                let r, g, b;
                if (hue < 1/6) { r = c; g = x; b = 0; }
                else if (hue < 2/6) { r = x; g = c; b = 0; }
                else if (hue < 3/6) { r = 0; g = c; b = x; }
                else if (hue < 4/6) { r = 0; g = x; b = c; }
                else if (hue < 5/6) { r = x; g = 0; b = c; }
                else { r = c; g = 0; b = x; }

                const color = Math.round((r + m) * 255) * 0x10000 + Math.round((g + m) * 255) * 0x100 + Math.round((b + m) * 255);

                return new THREE.MeshStandardMaterial({
                    wireframe: useWireframe,
                    transparent: true,
                    opacity: 1.0,
                    color: color,
                    metalness: 0.8,
                    roughness: 0.2
                });
            };

            // Initialize cube pool with default materials
            for (let i = 0; i < CUBE_POOL_SIZE; i++) {
                const defaultMaterial = createCubeMaterial(new THREE.Vector3(0, 1, 0), true); // Default upward, wireframe
                const cube = new THREE.Mesh(cubeGeometry, defaultMaterial);
                cube.visible = false;
                cube.userData.emissionDirection = new THREE.Vector3(0, 1, 0); // Default upward direction
                scene.add(cube);
                cubePool.push(cube);
            }

            // Get cube from pool
            const getCubeFromPool = () => {
                for (let cube of cubePool) {
                    if (!cube.visible) {
                        return cube;
                    }
                }
                return null; // Pool exhausted
            };

            

            // Emit cubes from spike group
            const emitCubesFromSpikes = (spikeGroup, count = 3, currentTime) => {
                for (let i = 0; i < Math.min(count, spikeGroup.length); i++) {
                    const spike = spikeGroup[i];
                    const cube = getCubeFromPool();
                    if (cube) {
                        // Position cube at spike tip (spike position + outward direction * spike height)
                        const spikeWorldPos = new THREE.Vector3();
                        spike.getWorldPosition(spikeWorldPos);
                        const outwardDir = spikeWorldPos.clone().normalize();
                        const tipPosition = spikeWorldPos.clone().add(outwardDir.multiplyScalar(0.4));

                        // Create material based on emission direction
                        const useWireframe = mesh.material.wireframe || false;
                        cube.material = createCubeMaterial(outwardDir, useWireframe);
                        cube.userData.emissionDirection = outwardDir.clone(); // Store for material updates

                        cube.position.copy(tipPosition);
                        cube.emissionPosition = tipPosition.clone();
                        cube.emissionTime = currentTime;
                        cube.scale.setScalar(1.0);
                        cube.castShadow = true; // Cubes also cast shadows
                        cube.visible = true;
                        activeCubes.push(cube);
                    }
                }
            };

            // Create spike groups
            const bassSpikes = [];
            const midSpikes = [];
            const highSpikes = [];

            // Helper function to create spikes at positions
            const createSpike = (position, group) => {
                const spike = new THREE.Mesh(spikeGeometry, wireframeMaterial); // Start with wireframe material since it's default
                spike.position.copy(position);
                spike.userData.originalPosition = position.clone(); // Store original position for extension
                spike.castShadow = true; // Spikes cast shadows on the sphere

                // Orient spike to point outward from sphere center
                // Calculate direction from origin to position
                const direction = position.clone().normalize();
                // Create quaternion that rotates Y-axis to point in the direction
                const up = new THREE.Vector3(0, 1, 0);
                const quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(up, direction);
                spike.setRotationFromQuaternion(quaternion);

                spikesContainer.add(spike);
                group.push(spike);
                return spike;
            };

            // Function to update spike positions based on base offset
            const updateSpikePositions = (baseOffset) => {
                // Clear existing spikes
                bassSpikes.length = 0;
                midSpikes.length = 0;
                highSpikes.length = 0;

                // Clear spikes container
                while (spikesContainer.children.length > 0) {
                    spikesContainer.remove(spikesContainer.children[0]);
                }

                // Recreate bass spikes (bottom hemisphere, 8 spikes)
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const radius = baseOffset; // Use dynamic base offset
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    const y = -Math.sqrt(Math.max(0, radius * radius - radius * radius * 0.1)); // Position on sphere surface
                    const spike = createSpike(new THREE.Vector3(x, y, z), bassSpikes);
                    spike.userData.originalPosition = new THREE.Vector3(x, y, z);
                }

                // Recreate mid spikes (equatorial, 12 spikes)
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const radius = baseOffset + 0.1; // Slightly further out
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    const y = 0; // Middle position
                    const spike = createSpike(new THREE.Vector3(x, y, z), midSpikes);
                    spike.userData.originalPosition = new THREE.Vector3(x, y, z);
                }

                // Recreate high spikes (top hemisphere, 6 spikes)
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const radius = baseOffset - 0.1; // Slightly closer
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    const y = Math.sqrt(Math.max(0, radius * radius - radius * radius * 0.1)); // Position on sphere surface
                    const spike = createSpike(new THREE.Vector3(x, y, z), highSpikes);
                    spike.userData.originalPosition = new THREE.Vector3(x, y, z);
                }
            };

            // Initialize spikes with default offset
            spikeBaseOffset = 1.6;
            updateSpikePositions(1.6);

            // Bloom parameters (disabled for WebGPU)
            // bloomStrength = 1.5;
            // bloomRadius = 0.4;
            // bloomThreshold = 0.85;

            // Spike offset slider setup (inside init scope)
            const spikeOffsetSlider = document.getElementById('spikeOffsetSlider');
            const spikeOffsetValue = document.getElementById('spikeOffsetValue');

            if (spikeOffsetSlider) {
                spikeOffsetSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    spikeBaseOffset = value;
                    if (spikeOffsetValue) {
                        spikeOffsetValue.textContent = value.toFixed(2);
                    }
                    updateSpikePositions(value);
                });

                // Initialize display value
                if (spikeOffsetValue) {
                    spikeOffsetValue.textContent = spikeBaseOffset.toFixed(2);
                }
            }

            // Bloom sliders disabled for WebGPU compatibility
            // Will re-enable with custom WebGPU bloom shader

            // Wireframe toggle functionality
            const wireframeToggle = document.getElementById('wireframeToggle');
            wireframeToggle.checked = true; // Enable wireframe by default
            mesh.material = wireframeMaterial; // Set wireframe as initial material

            // Function to update all materials (spikes and cubes)
            const updateAllMaterials = (useWireframe) => {
                const spikeMaterial = useWireframe ? wireframeMaterial : normalMaterial;

                [...bassSpikes, ...midSpikes, ...highSpikes].forEach(spike => {
                    spike.material = spikeMaterial;
                });

                // Update cube materials with direction-based colors
                [...activeCubes, ...cubePool].forEach(cube => {
                    if (cube.userData.emissionDirection) {
                        cube.material = createCubeMaterial(cube.userData.emissionDirection, useWireframe);
                        cube.material.opacity = 1.0; // Reset opacity
                    }
                });
            };

            // Set initial materials to wireframe
            updateAllMaterials(true);

            wireframeToggle.addEventListener('change', (e) => {
                const useWireframe = e.target.checked;
                mesh.material = useWireframe ? wireframeMaterial : normalMaterial;
                updateAllMaterials(useWireframe);
            });

            // Add lights with shadow casting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;

            // Configure shadow properties for high quality shadows
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            directionalLight.shadow.bias = -0.0001; // Reduce shadow acne
            directionalLight.shadow.normalBias = 0.02; // Reduce self-shadowing artifacts

            scene.add(directionalLight);

            // Animation loop
            const startTime = Date.now();
            renderer.setAnimationLoop(() => {
                // Update time uniform
                timeUniform.value = (Date.now() - startTime) / 1000;
                const time = timeUniform.value;

                updateAudio();
                updateEQ();

                // Update material specularity
                const specValue = specularity.value;
                normalMaterial.metalness = specValue;
                normalMaterial.roughness = 1.0 - specValue; // Inverse relationship
                wireframeMaterial.metalness = specValue;
                wireframeMaterial.roughness = 1.0 - specValue;

                // Bloom disabled for WebGPU compatibility
                // bloomPass.strength = bloomStrength;
                // bloomPass.radius = bloomRadius;
                // bloomPass.threshold = bloomThreshold;

                // Update spikes container rotation to match sphere rotation
                const rotationAngle = (time * rotationSpeed.value * Math.PI) / 180.0;
                spikesContainer.rotation.y = rotationAngle;

                // Update spike positions based on audio (extend outward instead of scaling)
                bassSpikes.forEach((spike, i) => {
                    const baseExtension = bassLevel * 0.8; // How far to extend
                    const animation = Math.sin(time * 3.0 + i * 0.5) * 0.2 + 0.9;
                    const totalExtension = baseExtension * animation;

                    // Calculate original base position and outward direction
                    const originalPos = spike.userData.originalPosition;
                    const outwardDir = originalPos.clone().normalize();

                    // Move spike tip outward along the normal
                    const extendedPos = originalPos.clone().add(outwardDir.clone().multiplyScalar(totalExtension));
                    spike.position.copy(extendedPos);

                    // Also scale the spike slightly for additional effect
                    spike.scale.setScalar(1.0 + baseExtension * 0.3);
                });

                midSpikes.forEach((spike, i) => {
                    const baseExtension = midLevel * 0.8;
                    const animation = Math.sin(time * 2.5 + i * 0.4) * 0.3 + 0.8;
                    const totalExtension = baseExtension * animation;

                    const originalPos = spike.userData.originalPosition;
                    const outwardDir = originalPos.clone().normalize();

                    const extendedPos = originalPos.clone().add(outwardDir.clone().multiplyScalar(totalExtension));
                    spike.position.copy(extendedPos);

                    spike.scale.setScalar(1.0 + baseExtension * 0.3);
                });

                highSpikes.forEach((spike, i) => {
                    const baseExtension = highLevel * 0.8;
                    const animation = Math.sin(time * 4.0 + i * 0.6) * 0.4 + 0.7;
                    const totalExtension = baseExtension * animation;

                    const originalPos = spike.userData.originalPosition;
                    const outwardDir = originalPos.clone().normalize();

                    const extendedPos = originalPos.clone().add(outwardDir.clone().multiplyScalar(totalExtension));
                    spike.position.copy(extendedPos);

                    spike.scale.setScalar(1.0 + baseExtension * 0.3);
                });

                // Cube emission and animation
                const currentTime = Date.now();

                // Check for frequency peaks and emit cubes
                if (bassLevel > 0.3 && currentTime - lastBassPeak > EMISSION_COOLDOWN) {
                    emitCubesFromSpikes(bassSpikes, 2, time);
                    lastBassPeak = currentTime;
                }
                if (midLevel > 0.6 && currentTime - lastMidPeak > EMISSION_COOLDOWN) {
                    emitCubesFromSpikes(midSpikes, 3, time);
                    lastMidPeak = currentTime;
                }
                if (highLevel > 0.6 && currentTime - lastHighPeak > EMISSION_COOLDOWN) {
                    emitCubesFromSpikes(highSpikes, 2, time);
                    lastHighPeak = currentTime;
                }

                // Animate active cubes
                for (let i = activeCubes.length - 1; i >= 0; i--) {
                    const cube = activeCubes[i];
                    const age = time - cube.emissionTime;
                    const speed = 3.0; // Units per second outward
                    const distance = age * speed;

                    // Calculate new position: emission position + outward direction * distance
                    const outwardDir = cube.emissionPosition.clone().normalize();
                    cube.position.copy(cube.emissionPosition).add(outwardDir.multiplyScalar(distance));

                    // Scale and fade based on distance from emission point
                    const distanceFromEmission = distance;
                    const maxDistance = 12.0; // Maximum travel distance

                    if (distanceFromEmission > maxDistance) {
                        // Remove cube
                        cube.visible = false;
                        activeCubes.splice(i, 1);
                    } else {
                        // Fade and scale based on distance
                        const fadeProgress = distanceFromEmission / maxDistance;
                        const brightness = Math.max(0.0, 1.0 - fadeProgress);
                        const scale = Math.max(0.1, 1.0 - fadeProgress * 0.8);

                        cube.material.opacity = brightness;
                        cube.scale.setScalar(scale);
                    }
                }

                controls.update(); // This should handle damping and zoom
                composer.render();
            });

            // Debug: Log camera info to verify controls and transformations
            let lastCameraPos = camera.position.clone();
            let lastCameraRot = camera.rotation.clone();
            setInterval(() => {
                const currentPos = camera.position;
                const currentRot = camera.rotation;
                if (!currentPos.equals(lastCameraPos) || !currentRot.equals(lastCameraRot)) {
                    // console.log('Camera - Pos:', currentPos, 'Rot X:', currentRot.x.toFixed(3), 'Y:', currentRot.y.toFixed(3), 'Z:', currentRot.z.toFixed(3), 'FOV:', camera.fov);
                    lastCameraPos.copy(currentPos);
                    lastCameraRot.copy(currentRot);
                }
            }, 200);

            // Test camera movement on key press
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowUp') camera.position.z -= 0.5;
                if (e.key === 'ArrowDown') camera.position.z += 0.5;
                if (e.key === 'ArrowLeft') camera.position.x -= 0.5;
                if (e.key === 'ArrowRight') camera.position.x += 0.5;
                camera.updateProjectionMatrix();
                console.log('Manual camera move - Pos:', camera.position);
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function setupEQ() {
            const columns = ['bassColumn', 'midColumn', 'highColumn'];

            columns.forEach(columnId => {
                const column = document.getElementById(columnId);

                // Create 6 segments for each column (bottom to top)
                for (let i = 0; i < 6; i++) {
                    const segment = document.createElement('div');
                    segment.className = 'eq-segment';

                    // Color coding: green (0-1), yellow (2-3), red (4-5)
                    if (i >= 4) segment.classList.add('red');
                    else if (i >= 2) segment.classList.add('yellow');
                    // else stays green

                    column.appendChild(segment);
                }
            });
        }

        function updateEQ() {
            // Update peaks
            bassPeak = Math.max(bassPeak, bassLevel);
            midPeak = Math.max(midPeak, midLevel);
            highPeak = Math.max(highPeak, highLevel);

            // Update segments for each column
            updateColumn('bassColumn', bassLevel, bassPeak);
            updateColumn('midColumn', midLevel, midPeak);
            updateColumn('highColumn', highLevel, highPeak);

            // Decay peaks over time
            bassPeak = Math.max(0, bassPeak - peakFallSpeed);
            midPeak = Math.max(0, midPeak - peakFallSpeed);
            highPeak = Math.max(0, highPeak - peakFallSpeed);
        }

        function updateColumn(columnId, level, peak) {
            const column = document.getElementById(columnId);
            const segments = column.querySelectorAll('.eq-segment');
            const peakElement = column.querySelector('.eq-peak');

            // Calculate which segments should be visible (0-6 based on level)
            const activeSegments = Math.floor(level * 6);

            // Update segment visibility
            segments.forEach((segment, index) => {
                if (index < activeSegments) {
                    segment.style.opacity = '1';
                } else {
                    segment.style.opacity = '0.2';
                }
            });

            // Update peak position (invert because we want it to go up)
            const peakPosition = (1 - peak) * 100; // Convert to percentage from bottom
            peakElement.style.top = `${peakPosition}%`;
        }

        async function setupAudio(src = '../audio/how.mp3') {
            try {
                // Get HTML5 audio element
                audioElement = document.getElementById('audioElement');
                if (!audioElement) {
                    console.error('Audio element not found in DOM');
                    return;
                }

                if (!audioInitialized) {
                    // First time setup - create Web Audio context and nodes
                    console.log('Initializing Web Audio for first time');

                    // Resume audio context and start playback on user interaction (required by browsers)
                    const resumeAudio = async (event) => {
                        // Only resume if clicking on the start note or non-interactive areas
                        if (event.target.id === 'startNote' ||
                            event.target === document.body ||
                            (!event.target.closest('#controls') && !event.target.closest('#eq') && !event.target.closest('#audioControls'))) {
                            if (audioContext && audioContext.state === 'suspended') {
                                await audioContext.resume();
                            }
                            // Start audio playback on first interaction
                            if (audioElement && audioElement.paused) {
                                audioElement.play().catch(e => console.error('Auto-play failed:', e));
                            }
                            console.log('Audio context resumed and playback started');
                            // Fade out the start note
                            const startNote = document.getElementById('startNote');
                            startNote.classList.add('hidden');
                        }
                    };
                    document.addEventListener('click', resumeAudio, { once: true });
                    document.addEventListener('touchstart', resumeAudio, { once: true });

                    audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Get HTML5 audio element
                audioElement = document.getElementById('audioElement');
                if (!audioElement) {
                    console.error('Audio element not found in DOM');
                    return;
                }
                console.log('Setting audio src to:', src);
                audioElement.src = src;
                audioElement.loop = true;
                audioElement.volume = 0.5; // Set initial volume

                // Wait for audio to be loaded
                await new Promise((resolve) => {
                    const onLoaded = () => {
                        console.log('Audio loaded successfully, duration:', audioElement.duration);
                        resolve();
                    };

                    if (audioElement.readyState >= 2) { // HAVE_CURRENT_DATA or higher
                        onLoaded();
                    } else {
                        audioElement.addEventListener('loadeddata', onLoaded, { once: true });
                        audioElement.addEventListener('error', (e) => {
                            console.error('Audio failed to load:', e);
                            resolve(); // Resolve anyway to continue
                        }, { once: true });

                        // Also try to load explicitly
                        audioElement.load();
                    }
                });

                console.log('Audio loaded, creating Web Audio connection');

                // Create audio source node from HTML5 audio element
                try {
                    audioSourceNode = audioContext.createMediaElementSource(audioElement);
                    console.log('Web Audio source node created successfully');
                } catch (e) {
                    console.error('Failed to create Web Audio source node:', e);
                    // Continue without Web Audio analysis
                }

                    // Create master gain node for volume control
                    masterGainNode = audioContext.createGain();
                    masterGainNode.gain.value = 0.5;
                    masterGainNode.connect(audioContext.destination);

                // Create analysers for frequency analysis
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                analyser.smoothingTimeConstant = 0.8;
                dataArray = new Uint8Array(analyser.frequencyBinCount);

                // Create bandpass filters for each frequency range
                bassFilter = audioContext.createBiquadFilter();
                bassFilter.type = 'bandpass';
                bassFilter.frequency.value = 100;
                bassFilter.Q.value = 2;

                midFilter = audioContext.createBiquadFilter();
                midFilter.type = 'bandpass';
                midFilter.frequency.value = 1000;
                midFilter.Q.value = 2;

                highFilter = audioContext.createBiquadFilter();
                highFilter.type = 'bandpass';
                highFilter.frequency.value = 5000;
                highFilter.Q.value = 2;

                const bassAnalyser = audioContext.createAnalyser();
                bassAnalyser.fftSize = 512;
                bassAnalyser.smoothingTimeConstant = 0.6;

                const midAnalyser = audioContext.createAnalyser();
                midAnalyser.fftSize = 512;
                midAnalyser.smoothingTimeConstant = 0.6;

                const highAnalyser = audioContext.createAnalyser();
                highAnalyser.fftSize = 512;
                highAnalyser.smoothingTimeConstant = 0.6;

                // Connect audio graph:
                // HTML5 audio -> source node -> filters -> analysers
                // HTML5 audio -> source node -> master gain -> destination
                audioSourceNode.connect(bassFilter);
                audioSourceNode.connect(midFilter);
                audioSourceNode.connect(highFilter);
                audioSourceNode.connect(masterGainNode);

                bassFilter.connect(bassAnalyser);
                midFilter.connect(midAnalyser);
                highFilter.connect(highAnalyser);

                masterGainNode.connect(audioContext.destination);

                // Store analysers for update loop
                window.bassAnalyser = bassAnalyser;
                window.midAnalyser = midAnalyser;
                window.highAnalyser = highAnalyser;
                window.bassData = new Uint8Array(bassAnalyser.frequencyBinCount);
                window.midData = new Uint8Array(midAnalyser.frequencyBinCount);
                window.highData = new Uint8Array(highAnalyser.frequencyBinCount);

                    // Try to resume audio context
                    if (audioContext.state === 'suspended') {
                        await audioContext.resume();
                    }

                    audioInitialized = true;
                }

                // Set audio source (works for both initial load and file changes)
                console.log('Setting audio src to:', src);
                audioElement.src = src;
                audioElement.loop = true;
                audioElement.volume = 0.5; // Set initial volume

                // Wait for audio to be loaded
                await new Promise((resolve) => {
                    const onLoaded = () => {
                        console.log('Audio loaded successfully, duration:', audioElement.duration);
                        resolve();
                    };

                    if (audioElement.readyState >= 2) { // HAVE_CURRENT_DATA or higher
                        onLoaded();
                    } else {
                        audioElement.addEventListener('loadeddata', onLoaded, { once: true });
                        audioElement.addEventListener('error', () => {
                            console.error('Audio failed to load');
                            resolve(); // Resolve anyway to continue
                        }, { once: true });

                        // Also try to load explicitly
                        audioElement.load();
                    }
                });

                document.getElementById('info').textContent = 'Audio ready - Click to interact';

            } catch (error) {
                console.error('Audio setup error:', error);
                document.getElementById('info').textContent = 'Audio error: ' + error.message;
            }
        }

        function updateAudio() {
            if (!window.bassAnalyser) return;

            // Get frequency data for each band
            window.bassAnalyser.getByteFrequencyData(window.bassData);
            window.midAnalyser.getByteFrequencyData(window.midData);
            window.highAnalyser.getByteFrequencyData(window.highData);

            // Calculate RMS (root mean square) for each band for smoother response
            let bassSum = 0, midSum = 0, highSum = 0;
            const bassCount = window.bassData.length;
            const midCount = window.midData.length;
            const highCount = window.highData.length;

            for (let i = 0; i < bassCount; i++) {
                const val = window.bassData[i] / 255;
                bassSum += val * val;
            }
            for (let i = 0; i < midCount; i++) {
                const val = window.midData[i] / 255;
                midSum += val * val;
            }
            for (let i = 0; i < highCount; i++) {
                const val = window.highData[i] / 255;
                highSum += val * val;
            }

            // Calculate RMS and amplify
            bassLevel = Math.sqrt(bassSum / bassCount) * 3;
            midLevel = Math.sqrt(midSum / midCount) * 2.5;
            highLevel = Math.sqrt(highSum / highCount) * 2;

            // Clamp and smooth
            bassLevel = Math.min(bassLevel, 1.5);
            midLevel = Math.min(midLevel, 1.2);
            highLevel = Math.min(highLevel, 1.0);

            // Update uniforms
            if (bassUniform) bassUniform.value = bassLevel;
            if (midUniform) midUniform.value = midLevel;
            if (highUniform) highUniform.value = highLevel;

            // Update info
            // document.getElementById('info').innerHTML =
            //     `Bass: ${bassLevel.toFixed(2)}<br>` +
            //     `Mid: ${midLevel.toFixed(2)}<br>` +
            //     `High: ${highLevel.toFixed(2)}`;
        }

        // ImGui Control Panel Setup
        function setupImGuiControls() {
            // Collapsible functionality
            const imguiWindow = document.querySelector('.imgui-window');
            const imguiTitle = document.querySelector('.imgui-title');

            // Start collapsed by default
            imguiWindow.classList.add('collapsed');

            imguiTitle.addEventListener('click', () => {
                imguiWindow.classList.toggle('collapsed');
            });

            const amplitudeSlider = document.getElementById('amplitudeSlider');
            const amplitudeValue = document.getElementById('amplitudeValue');
            const noiseScaleSlider = document.getElementById('noiseScaleSlider');
            const noiseScaleValue = document.getElementById('noiseScaleValue');
            const noiseFreqSlider = document.getElementById('noiseFreqSlider');
            const noiseFreqValue = document.getElementById('noiseFreqValue');
            const timeModSlider = document.getElementById('timeModSlider');
            const timeModValue = document.getElementById('timeModValue');
                const rotationSpeedSlider = document.getElementById('rotationSpeedSlider');
                const rotationSpeedValue = document.getElementById('rotationSpeedValue');
                const specularitySlider = document.getElementById('specularitySlider');
                const specularityValue = document.getElementById('specularityValue');

            // Amplitude control
            amplitudeSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                wobbleAmplitude.value = value;
                amplitudeValue.textContent = value.toFixed(2);
            });

            // Noise scale control
            noiseScaleSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                noiseScale.value = value;
                noiseScaleValue.textContent = value.toFixed(1);
            });

            // Noise frequency control
            noiseFreqSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                noiseFrequency.value = value;
                noiseFreqValue.textContent = value.toFixed(1);
            });

            // Time modulation control
            timeModSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                timeModulation.value = value;
                timeModValue.textContent = value.toFixed(1);
            });

            // Rotation speed control
            rotationSpeedSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                rotationSpeed.value = value;
                rotationSpeedValue.textContent = value.toFixed(1);
            });

            // Specularity control
            specularitySlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                specularity.value = value;
                specularityValue.textContent = value.toFixed(2);
            });

            // Initialize display values
            amplitudeValue.textContent = wobbleAmplitude.value.toFixed(2);
            noiseScaleValue.textContent = noiseScale.value.toFixed(1);
            noiseFreqValue.textContent = noiseFrequency.value.toFixed(1);
            timeModValue.textContent = timeModulation.value.toFixed(1);
            rotationSpeedValue.textContent = rotationSpeed.value.toFixed(1);
            specularityValue.textContent = specularity.value.toFixed(2);
        }

        function setupAudioStuff() {

            // Setup file input and upload button
            const audioFileInput = document.getElementById('audioFileInput');
            const uploadBtn = document.getElementById('uploadBtn');

            if (uploadBtn) {
                uploadBtn.addEventListener('click', () => {
                    console.log('Upload button clicked');
                    if (audioFileInput) {
                        audioFileInput.click();
                    } else {
                        console.error('Audio file input not found');
                    }
                });
                console.log('Upload button listener attached');
            } else {
                console.error('Upload button not found');
            }

            if (audioFileInput) {
                audioFileInput.addEventListener('change', async (event) => {
                    console.log('File input changed, files:', event.target.files.length);
                    const file = event.target.files[0];
                    if (file) {
                        try {
                            // Stop current audio
                            if (audioElement) {
                                audioElement.pause();
                                audioElement.currentTime = 0;
                            }

                            // Create object URL for the file
                            const fileURL = URL.createObjectURL(file);

                            // Load new audio file
                            await setupAudio(fileURL);

                            // Update controls
                            updateAudioControls();

                            console.log('Loaded new audio file:', file.name);

                            // Play the newly loaded audio automatically
                            // if (audioElement) {
                            //     await audioElement.play().catch(e => {
                            //         console.error('Auto-play failed after file load:', e);
                            //     });
                            // }
                        } catch (error) {
                            console.error('Error loading audio file:', error);
                            alert('Error loading audio file: ' + error.message);
                        }
                    }
                });
            }

            // Setup audio control event listeners
            const audioPlayPauseBtn = document.getElementById('playPauseBtn');
            const audioSeekSlider = document.getElementById('seekSlider');
            const audioVolumeSlider = document.getElementById('volumeSlider');

            if (audioPlayPauseBtn) {
                audioPlayPauseBtn.addEventListener('click', playAudio);
                console.log('Play/pause button listener attached');
            } else {
                console.error('Play/pause button not found');
            }

            if (audioSeekSlider) {
                audioSeekSlider.addEventListener('input', (e) => seekAudio(parseFloat(e.target.value) / 100));
                console.log('Seek slider listener attached');
            } else {
                console.error('Seek slider not found');
            }

            if (audioVolumeSlider) {
                audioVolumeSlider.addEventListener('input', (e) => setVolume(parseFloat(e.target.value)));
                console.log('Volume slider listener attached');
            } else {
                console.error('Volume slider not found');
            }

            // Audio element event listeners
            if (audioElement) {
                audioElement.addEventListener('loadedmetadata', () => {
                    console.log('Audio loaded, duration:', audioElement.duration);
                    updateAudioControls();
                });
                audioElement.addEventListener('timeupdate', updateAudioControls);
                audioElement.addEventListener('play', () => {
                    console.log('Audio started playing');
                    updateAudioControls();
                });
                audioElement.addEventListener('pause', () => {
                    console.log('Audio paused');
                    updateAudioControls();
                });
                audioElement.addEventListener('volumechange', () => {
                    console.log('Volume changed to:', audioElement.volume);
                    updateAudioControls();
                });
                audioElement.addEventListener('error', (e) => {
                    console.error('Audio error:', e);
                });
                console.log('Audio element event listeners attached');
            } else {
                console.error('Audio element not found for event listeners');
            }

            // Initialize controls
            console.log('Initializing audio controls...');
            updateAudioControls();

            // Set initial volume
            if (audioElement) {
                console.log('Setting initial volume for audio element');
                setVolume(audioElement.volume);
            } else {
                console.error('Audio element not available for initialization');
            }
                async function playAudio() {
                    if (!audioElement) {
                        console.error('Audio element not found');
                        return;
                    }

                    console.log('Play/pause clicked, current state:', audioElement.paused ? 'paused' : 'playing');

                    try {
                        // Resume Web Audio context if needed
                        if (audioContext && audioContext.state === 'suspended') {
                            await audioContext.resume();
                            console.log('Web Audio context resumed');
                        }

                        if (audioElement.paused) {
                            await audioElement.play();
                            console.log('Audio started playing');
                        } else {
                            audioElement.pause();
                            console.log('Audio paused');
                        }
                    } catch (e) {
                        console.error('Audio control failed:', e);
                    }
                }

                function seekAudio(position) {
                    if (!audioElement) {
                        console.error('Audio element not found');
                        return;
                    }
                    if (!isNaN(audioElement.duration) && audioElement.duration > 0) {
                        const newTime = position * audioElement.duration;
                        audioElement.currentTime = newTime;
                        console.log('Seeked to:', newTime, 'of', audioElement.duration);
                    } else {
                        console.warn('Cannot seek: invalid duration');
                    }
                }

            function setVolume(volume) {
                if (audioElement) {
                    audioElement.volume = volume;
                    console.log('Volume set to:', volume);
                }
                // Also update the volume slider to reflect current volume
                const audioVolumeSlider = document.getElementById('volumeSlider');
                if (audioVolumeSlider) {
                    audioVolumeSlider.value = volume;
                }
            }

                function updateAudioControls() {
                    if (!audioElement) return;

                    const playPauseBtn = document.getElementById('playPauseBtn');
                    const seekSlider = document.getElementById('seekSlider');
                    const currentTimeSpan = document.getElementById('currentTime');
                    const durationSpan = document.getElementById('duration');
                    const volumeSlider = document.getElementById('volumeSlider');

                    // Update play/pause button
                    playPauseBtn.textContent = audioElement.paused ? '‚ñ∂Ô∏è Play' : '‚è∏Ô∏è Pause';

                    // Update duration
                    if (!isNaN(audioElement.duration)) {
                        durationSpan.textContent = formatTime(audioElement.duration);
                    }

                    // Update current time and seek slider
                    if (!isNaN(audioElement.duration) && audioElement.duration > 0) {
                        currentTimeSpan.textContent = formatTime(audioElement.currentTime);
                        seekSlider.value = (audioElement.currentTime / audioElement.duration) * 100;
                    }

                // Update volume slider
                if (audioVolumeSlider) {
                    audioVolumeSlider.value = audioElement.volume;
                }
                }

                function formatTime(seconds) {
                    if (isNaN(seconds)) return '0:00';
                    const mins = Math.floor(seconds / 60);
                    const secs = Math.floor(seconds % 60);
                    return `${mins}:${secs.toString().padStart(2, '0')}`;
                }

                // Setup audio control event listeners
                const playPauseBtn = document.getElementById('playPauseBtn');
                const seekSlider = document.getElementById('seekSlider');
                const volumeSlider = document.getElementById('volumeSlider');

                if (playPauseBtn) {
                    playPauseBtn.addEventListener('click', playAudio);
                    console.log('Play/pause button listener attached');
                } else {
                    console.error('Play/pause button not found');
                }

                if (seekSlider) {
                    seekSlider.addEventListener('input', (e) => seekAudio(parseFloat(e.target.value) / 100));
                    console.log('Seek slider listener attached');
                } else {
                    console.error('Seek slider not found');
                }

                if (volumeSlider) {
                    volumeSlider.addEventListener('input', (e) => setVolume(parseFloat(e.target.value)));
                    console.log('Volume slider listener attached');
                } else {
                    console.error('Volume slider not found');
                }

                // Audio element event listeners
                if (audioElement) {
                    audioElement.addEventListener('loadedmetadata', () => {
                        console.log('Audio loaded, duration:', audioElement.duration);
                        updateAudioControls();
                    });
                    audioElement.addEventListener('timeupdate', updateAudioControls);
                    audioElement.addEventListener('play', () => {
                        console.log('Audio started playing');
                        updateAudioControls();
                    });
                    audioElement.addEventListener('pause', () => {
                        console.log('Audio paused');
                        updateAudioControls();
                    });
                    audioElement.addEventListener('volumechange', () => {
                        console.log('Volume changed to:', audioElement.volume);
                        updateAudioControls();
                    });
                    audioElement.addEventListener('error', (e) => {
                        console.error('Audio error:', e);
                    });
                    console.log('Audio element event listeners attached');
                } else {
                    console.error('Audio element not found for event listeners');
                }

                // Initialize controls
                console.log('Initializing audio controls...');
                updateAudioControls();

                // Set initial volume
                if (audioElement) {
                    console.log('Setting initial volume for audio element');
                    setVolume(audioElement.volume);
                } else {
                    console.error('Audio element not available for initialization');
                }
            }

            (async () => {
                // Wait for DOM to be ready
                if (document.readyState === 'loading') {
                    await new Promise(resolve => {
                        document.addEventListener('DOMContentLoaded', resolve);
                    });
                }

                // Setup audio first
                await setupAudio();

                await init();

                // Call setup after everything is initialized
                setupImGuiControls();

                setupAudioStuff();
            })();
    </script>
</body>

</html>