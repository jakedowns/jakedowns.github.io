<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Compute Shader - Mouse Influence Particles | jakedowns.com</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        a {
            color: white;
        }
        .credits {
            position: absolute;
            bottom: 20px;
            color: white;
            text-align: center;
            width: 500px;
            margin: 0 auto;
            left: 50%;
            margin-left: -250px;
        }
    </style>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-QJL8TTXHJR"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-QJL8TTXHJR');
    </script>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 10.0;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Orbit controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Grid parameters
        const GRID_SIZE = 64.0;
        const TOTAL_POINTS = GRID_SIZE * GRID_SIZE;
        
        // Create initial positions and velocities
        const positions = new Float32Array(TOTAL_POINTS * 3);
        const velocities = new Float32Array(TOTAL_POINTS * 3);
        const origins = new Float32Array(TOTAL_POINTS * 3);
        
        let index = 0;
        const spacing = 0.3;
        
        for (let i = 0; i < GRID_SIZE; i++) {
            for (let j = 0; j < GRID_SIZE; j++) {
                const x = (i / GRID_SIZE - 0.5) * GRID_SIZE * spacing;
                const y = (j / GRID_SIZE - 0.5) * GRID_SIZE * spacing;
                const z = 0;
                
                positions[index * 3] = x;
                positions[index * 3 + 1] = y;
                positions[index * 3 + 2] = z;
                
                origins[index * 3] = x;
                origins[index * 3 + 1] = y;
                origins[index * 3 + 2] = z;
                
                velocities[index * 3] = 0;
                velocities[index * 3 + 1] = 0;
                velocities[index * 3 + 2] = 0;
                
                index++;
            }
        }

        // GPU Compute setup
        const gpuCompute = new GPUComputationRenderer(GRID_SIZE, GRID_SIZE, renderer);
        
        // if (!gpuCompute.init()) {
        //     console.error('GPU computation not supported');
        // }

        // Position texture
        const positionTexture = gpuCompute.createTexture();
        const velocityTexture = gpuCompute.createTexture();
        
        fillTexture(positionTexture, positions);
        fillTexture(velocityTexture, velocities);

        function fillTexture(texture, data) {
            const image = texture.image;
            for (let i = 0; i < data.length; i += 3) {
                const index = i / 3;
                const x = index % GRID_SIZE;
                const y = Math.floor(index / GRID_SIZE);
                
                image.data[x * 4 + y * GRID_SIZE * 4] = data[i];     // R = x
                image.data[x * 4 + y * GRID_SIZE * 4 + 1] = data[i + 1]; // G = y
                image.data[x * 4 + y * GRID_SIZE * 4 + 2] = data[i + 2]; // B = z
                image.data[x * 4 + y * GRID_SIZE * 4 + 3] = 1.0;         // A
            }
        }

        // Compute shader for physics simulation
        const positionVariable = gpuCompute.addVariable('texturePosition', getPositionFragmentShader(), positionTexture);
        const velocityVariable = gpuCompute.addVariable('textureVel', getVelocityFragmentShader(), velocityTexture);
        
        gpuCompute.setVariableDependencies(positionVariable, [positionVariable, velocityVariable]);
        gpuCompute.setVariableDependencies(velocityVariable, [velocityVariable, positionVariable]);

        const uniformsPosition = positionVariable.material.uniforms;
        const uniformsVelocity = velocityVariable.material.uniforms;
        
        uniformsPosition.textureVel = { value: null };
        uniformsPosition.originTexture = { value: createOriginTexture() };
        uniformsPosition.returnSpeed = { value: 1.0 };
        
        uniformsVelocity.mousePos = { value: new THREE.Vector2() };
        uniformsVelocity.mouseVel = { value: new THREE.Vector2() };
        uniformsVelocity.mouseInfluenceRadius = { value: 2.0 };
        uniformsVelocity.mouseStrength = { value: 10.0 };
        uniformsVelocity.fieldDecay = { value: 0.99 };
        uniformsVelocity.maxVelocity = { value: 20.0 };

        const error = gpuCompute.init();
        if (error !== null) {
            console.error(error);
        }

        function createOriginTexture() {
            const texture = new THREE.DataTexture(
                new Float32Array(TOTAL_POINTS * 4),
                GRID_SIZE,
                GRID_SIZE,
                THREE.RGBAFormat,
                THREE.FloatType
            );
            texture.needsUpdate = true;
            
            const image = texture.image;
            for (let i = 0; i < origins.length; i += 3) {
                const index = i / 3;
                const x = index % GRID_SIZE;
                const y = Math.floor(index / GRID_SIZE);
                
                image.data[x * 4 + y * GRID_SIZE * 4] = origins[i];
                image.data[x * 4 + y * GRID_SIZE * 4 + 1] = origins[i + 1];
                image.data[x * 4 + y * GRID_SIZE * 4 + 2] = origins[i + 2];
                image.data[x * 4 + y * GRID_SIZE * 4 + 3] = 1.0;
            }
            
            return texture;
        }

        function getPositionFragmentShader() {
            return `
                uniform sampler2D originTexture;
                uniform float returnSpeed;

                void main() {
                    vec2 uv = gl_FragCoord.xy / resolution.xy;
                    vec4 pos = texture2D(texturePosition, uv);
                    vec4 fieldVel = texture2D(textureVel, uv);
                    vec4 origin = texture2D(originTexture, uv);
                    
                    // Advect position through the flow field
                    vec3 newPos = pos.xyz + fieldVel.xyz * 0.01;
                    
                    // Slowly return to origin if far from it
                    vec3 distToOrigin = origin.xyz - newPos;
                    float distMag = length(distToOrigin);
                    if (distMag > 0.1) {
                        newPos = mix(newPos, origin.xyz, returnSpeed * 0.1);
                    }
                    
                    gl_FragColor = vec4(newPos, 1.0);
                }
            `;
        }

        function getVelocityFragmentShader() {
            return `
                uniform vec2 mousePos;
                uniform vec2 mouseVel;
                uniform float mouseInfluenceRadius;
                uniform float mouseStrength;
                uniform float fieldDecay;
                uniform float maxVelocity;

                void main() {
                    vec2 uv = gl_FragCoord.xy / resolution.xy;
                    vec4 fieldVel = texture2D(textureVel, uv);
                    
                    // Current field velocity at this point
                    vec2 currentVel = fieldVel.xy;
                    
                    // Convert UV to world space position (grid coordinates)
                    // UV is [0,1] -> world space is approximately [-10, 10] for 64x64 grid
                    vec2 fieldWorldPos = (uv - 0.5) * 64.0 * 0.5;
                    
                    // Flip x and y of fieldWorldPos
                    fieldWorldPos = fieldWorldPos.yx;
                    
                    // Convert mouse position from screen space to world space
                    vec2 mouseWorldPos = mousePos * 15.0;
                    
                    // Calculate distance from this field point to mouse position
                    vec2 dist = fieldWorldPos - mouseWorldPos;
                    float distMag = length(dist);
                    
                    // Smooth falloff function based on distance
                    float mouseVelMag = length(mouseVel);
                    if (mouseVelMag > 0.001 && distMag < mouseInfluenceRadius) {
                        // Smooth falloff: 1.0 at mouse, 0.0 at edge of influence radius
                        float influenceFactor = 1.0 - smoothstep(0.0, mouseInfluenceRadius, distMag);
                        influenceFactor = pow(influenceFactor, 2.0); // Smooth curve
                        
                        // Impart mouse velocity onto the field with falloff
                        vec2 mouseWorldVel = mouseVel * 15.0;
                        currentVel = mix(currentVel, mouseWorldVel * mouseStrength, influenceFactor);
                    }
                    
                    // Decay field velocity (when not influenced by mouse)
                    float mouseInfluenceAtPoint = 0.0;
                    if (distMag < mouseInfluenceRadius && mouseVelMag > 0.001) {
                        mouseInfluenceAtPoint = 1.0 - smoothstep(0.0, mouseInfluenceRadius, distMag);
                    }
                    
                    // Decay more when mouse is not influencing this region
                    float decayFactor = mix(fieldDecay, 1.0, mouseInfluenceAtPoint);
                    currentVel *= decayFactor;
                    
                    // Clamp velocity
                    float velMag = length(currentVel);
                    if (velMag > maxVelocity) {
                        currentVel = normalize(currentVel) * maxVelocity;
                    }
                    
                    gl_FragColor = vec4(currentVel, 0.0, 1.0);
                }
            `;
        }

        // Render shader - points with velocity-based color
        // Create UV coordinates for texture sampling
        const uvs = new Float32Array(TOTAL_POINTS * 2);
        for (let i = 0; i < GRID_SIZE; i++) {
            for (let j = 0; j < GRID_SIZE; j++) {
                const idx = i * GRID_SIZE + j;
                uvs[idx * 2] = (j + 0.5) / GRID_SIZE; // x coordinate
                uvs[idx * 2 + 1] = (i + 0.5) / GRID_SIZE; // y coordinate
            }
        }
        
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
        
        const pointMaterial = new THREE.ShaderMaterial({
            uniforms: {
                texturePosition: { value: null },
                textureVel: { value: null },
                pointSize: { value: 10.0 }
            },
            vertexShader: `
                uniform sampler2D texturePosition;
                uniform sampler2D textureVel;
                uniform float pointSize;
                
                varying vec3 vColor;
                
                void main() {
                    vec4 pos = texture2D(texturePosition, uv);
                    vec4 vel = texture2D(textureVel, uv);
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos.xyz, 1.0);
                    gl_PointSize = pointSize;
                    
                    float velMag = length(vel.xy);
                    
                    // Color based on velocity: blue (0) to red (high)
                    // For medium velocity, mix to purple
                    float normalizedVel = clamp(velMag / 3.0, 0.0, 1.0);
                    
                    if (normalizedVel < 0.5) {
                        // Blue to purple
                        vec3 color1 = vec3(0.0, 0.0, 1.0); // blue
                        vec3 color2 = vec3(0.5, 0.0, 0.5); // purple
                        vColor = mix(color1, color2, normalizedVel * 2.0);
                    } else {
                        // Purple to red
                        vec3 color1 = vec3(0.5, 0.0, 0.5); // purple
                        vec3 color2 = vec3(1.0, 0.0, 0.0); // red
                        vColor = mix(color1, color2, (normalizedVel - 0.5) * 2.0);
                    }
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                
                void main() {
                    // Circular point
                    vec2 coord = gl_PointCoord - vec2(0.5);
                    if (dot(coord, coord) > 0.25) discard;
                    
                    gl_FragColor = vec4(vColor, 1.0);
                }
            `,
            transparent: true
        });

        const points = new THREE.Points(geometry, pointMaterial);
        scene.add(points);

        // Mouse tracking
        const mouse = new THREE.Vector2();
        const mouseVel = new THREE.Vector2();
        const lastMouse = new THREE.Vector2();
        let lastMouseTime = Date.now();
        let firstMouseMove = true;
        const rawVel = [];

        function onMouseMove(event) {
            const now = Date.now();
            const deltaTime = Math.max(1, now - lastMouseTime) / 1000.0; // Convert to seconds
            
            if (firstMouseMove) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                lastMouse.set(mouse.x, mouse.y);
                firstMouseMove = false;
                lastMouseTime = now;
                return;
            }
            
            lastMouse.set(mouse.x, mouse.y);
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Calculate mouse velocity (screen space delta)
            if (deltaTime > 0) {
                rawVel[0] = (mouse.x - lastMouse.x) / deltaTime;
                rawVel[1] = (mouse.y - lastMouse.y) / deltaTime;
                mouseVel.set(
                    rawVel[0],
                    rawVel[1]
                );

                //uniformsVelocity.mouseInfluenceRadius.value = (Math.abs(rawVel[0]) + Math.abs(rawVel[1])) * 0.3;
                uniformsVelocity.mouseStrength.value = uniformsVelocity.mouseInfluenceRadius.value;
            }
            
            lastMouseTime = now;
        }

        window.addEventListener('mousemove', onMouseMove);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update orbit controls
            controls.update();
            
            // Decay mouse velocity over time (smooth decay when not moving)
            mouseVel.multiplyScalar(0.95);
            
            // Update uniforms
            uniformsVelocity.mousePos.value.set(mouse.x, mouse.y);
            uniformsVelocity.mouseVel.value.set(mouseVel.x, mouseVel.y);
            
            // Run compute shaders
            gpuCompute.compute();
            
            // Update render uniforms with compute textures
            pointMaterial.uniforms.texturePosition.value = gpuCompute.getCurrentRenderTarget(positionVariable).texture;
            pointMaterial.uniforms.textureVel.value = gpuCompute.getCurrentRenderTarget(velocityVariable).texture;
            
            renderer.render(scene, camera);
        }

        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener('resize', onWindowResize);

        animate();
    </script>
    <p class="credits">
        <a href="https://github.com/jakedowns/jakedowns.github.io">View Source on Github.com/jakedowns</a>
    </p>
</body>
</html>
