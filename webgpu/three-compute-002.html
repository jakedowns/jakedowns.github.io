<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Compute Shader - Mouse Influence Particles - 002 | jakedowns.com</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
            -webkit-user-select: none; /* Disable text selection on mobile */
        }
        canvas {
            display: block;
        }
        .instructions {
            position: absolute;
            top: 10px;
            color: white;
            text-align: center;
            width: 500px;
            margin: 0 auto;
            left: 50%;
            margin-left: -250px;
        }
        a {
            color: white;
        }
        .credits {
            position: absolute;
            bottom: 10px;
            color: white;
            text-align: center;
            width: 500px;
            margin: 0 auto;
            left: 50%;
            margin-left: -250px;
        }
    </style>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-QJL8TTXHJR"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-QJL8TTXHJR');
    </script>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 10.0;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Post-processing setup
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));

        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0.5, // strength
            0.0, // radius
            0.0  // threshold
        );
        composer.addPass(bloomPass);

        // GUI setup
        const gui = new GUI();
        const bloomFolder = gui.addFolder('Bloom');
        bloomFolder.add(bloomPass, 'strength', 0, 3).onChange(value => bloomPass.strength = Number(value));
        bloomFolder.add(bloomPass, 'radius', 0, 1).onChange(value => bloomPass.radius = Number(value));
        bloomFolder.add(bloomPass, 'threshold', 0, 1).onChange(value => bloomPass.threshold = Number(value));
        bloomFolder.open();

        // Grid parameters
        const GRID_SIZE = 64;
        const TOTAL_POINTS = GRID_SIZE * GRID_SIZE;
        
        // Create initial positions and velocities
        const positions = new Float32Array(TOTAL_POINTS * 3);
        const velocities = new Float32Array(TOTAL_POINTS * 3);
        const origins = new Float32Array(TOTAL_POINTS * 3);
        
        let index = 0;
        const spacing = 0.3;
        
        for (let i = 0; i < GRID_SIZE; i++) {
            for (let j = 0; j < GRID_SIZE; j++) {
                const x = (i / GRID_SIZE - 0.5) * GRID_SIZE * spacing;
                const y = (j / GRID_SIZE - 0.5) * GRID_SIZE * spacing;
                const z = 0;
                
                positions[index * 3] = x;
                positions[index * 3 + 1] = y;
                positions[index * 3 + 2] = z;
                
                origins[index * 3] = x;
                origins[index * 3 + 1] = y;
                origins[index * 3 + 2] = z;
                
                velocities[index * 3] = 0;
                velocities[index * 3 + 1] = 0;
                velocities[index * 3 + 2] = 0;
                
                index++;
            }
        }

        // GPU Compute setup
        const gpuCompute = new GPUComputationRenderer(GRID_SIZE, GRID_SIZE, renderer);
        
        if (!gpuCompute.init()) {
            console.error('GPU computation not supported');
        }

        // Position texture
        const positionTexture = gpuCompute.createTexture();
        const velocityTexture = gpuCompute.createTexture();
        
        fillTexture(positionTexture, positions);
        fillTexture(velocityTexture, velocities);

        function fillTexture(texture, data) {
            const image = texture.image;
            for (let i = 0; i < data.length; i += 3) {
                const index = i / 3;
                const x = index % GRID_SIZE;
                const y = Math.floor(index / GRID_SIZE);
                
                image.data[x * 4 + y * GRID_SIZE * 4] = data[i];     // R = x
                image.data[x * 4 + y * GRID_SIZE * 4 + 1] = data[i + 1]; // G = y
                image.data[x * 4 + y * GRID_SIZE * 4 + 2] = data[i + 2]; // B = z
                image.data[x * 4 + y * GRID_SIZE * 4 + 3] = 1.0;         // A
            }
        }

        // Compute shader for physics simulation
        const positionVariable = gpuCompute.addVariable('texturePosition', getPositionFragmentShader(), positionTexture);
        const velocityVariable = gpuCompute.addVariable('textureVel', getVelocityFragmentShader(), velocityTexture);
        
        gpuCompute.setVariableDependencies(positionVariable, [positionVariable, velocityVariable]);
        gpuCompute.setVariableDependencies(velocityVariable, [velocityVariable, positionVariable]);

        const uniformsPosition = positionVariable.material.uniforms;
        const uniformsVelocity = velocityVariable.material.uniforms;
        
        uniformsPosition.textureVel = { value: null };
        uniformsPosition.mousePos = { value: new THREE.Vector2() };
        uniformsPosition.mouseInfluence = { value: 0.0 };
        uniformsPosition.returnSpeed = { value: 0.05 };
        uniformsPosition.originTexture = { value: createOriginTexture() };
        
        uniformsVelocity.mousePos = { value: new THREE.Vector2() };
        uniformsVelocity.mouseInfluence = { value: 0.0 };
        uniformsVelocity.mousePressed = { value: 0.0 };
        uniformsVelocity.mouseStrength = { value: 0.5 };
        uniformsVelocity.inertia = { value: 0.98 };
        uniformsVelocity.maxVelocity = { value: 5.0 };
        uniformsVelocity.damping = { value: 0.93 };

        const error = gpuCompute.init();
        if (error !== null) {
            console.error(error);
        }

        function createOriginTexture() {
            const texture = new THREE.DataTexture(
                new Float32Array(TOTAL_POINTS * 4),
                GRID_SIZE,
                GRID_SIZE,
                THREE.RGBAFormat,
                THREE.FloatType
            );
            texture.needsUpdate = true;
            
            const image = texture.image;
            for (let i = 0; i < origins.length; i += 3) {
                const index = i / 3;
                const x = index % GRID_SIZE;
                const y = Math.floor(index / GRID_SIZE);
                
                image.data[x * 4 + y * GRID_SIZE * 4] = origins[i];
                image.data[x * 4 + y * GRID_SIZE * 4 + 1] = origins[i + 1];
                image.data[x * 4 + y * GRID_SIZE * 4 + 2] = origins[i + 2];
                image.data[x * 4 + y * GRID_SIZE * 4 + 3] = 1.0;
            }
            
            return texture;
        }

        function getPositionFragmentShader() {
            return `
                uniform sampler2D originTexture;
                uniform vec2 mousePos;
                uniform float mouseInfluence;
                uniform float returnSpeed;

                void main() {
                    vec2 uv = gl_FragCoord.xy / resolution.xy;
                    vec4 pos = texture2D(texturePosition, uv);
                    vec4 vel = texture2D(textureVel, uv);
                    vec4 origin = texture2D(originTexture, uv);
                    
                    // Update position based on velocity
                    vec3 newPos = pos.xyz + vel.xyz * 0.01;
                    
                    // Lerp back to origin when mouse is not moving
                    if (mouseInfluence < 0.01) {
                        newPos = mix(newPos, origin.xyz, returnSpeed);
                    }
                    
                    gl_FragColor = vec4(newPos, 1.0);
                }
            `;
        }

        function getVelocityFragmentShader() {
            return `
                uniform vec2 mousePos;
                uniform float mouseInfluence;
                uniform float mousePressed;
                uniform float mouseStrength;
                uniform float inertia;
                uniform float maxVelocity;
                uniform float damping;

                void main() {
                    vec2 uv = gl_FragCoord.xy / resolution.xy;
                    vec4 pos = texture2D(texturePosition, uv);
                    vec4 vel = texture2D(textureVel, uv);
                    
                    vec3 currentVel = vel.xyz;
                    
                    // Apply mouse influence
                    if (mouseInfluence > 0.01) {
                        // Convert mouse position from screen space to world space
                        // Mouse is in [-1, 1] range, world is about [-10, 10] for a 64x64 grid
                        vec2 mouseWorldPos = mousePos * 15.0;
                        vec2 dist = mouseWorldPos - pos.xy;
                        float distMag = length(dist);
                        
                        // Calculate influence based on distance
                        float influenceRange = 6.0;
                        float influenceFactor = 1.0 - clamp(distMag / influenceRange, 0.0, 1.0);
                        influenceFactor = pow(influenceFactor, 2.0);
                        
                        // Apply force: positive (attractive) when not pressed, negative (repulsive) when pressed
                        if (distMag > 0.001) {
                            float forceDirection = mousePressed > 0.5 ? -1.0 : 1.0;
                            vec2 force = normalize(dist) * mouseStrength * influenceFactor * mouseInfluence * forceDirection;
                            currentVel.xy += force;
                        }
                    }
                    
                    // Apply inertia (momentum)
                    currentVel *= inertia;
                    
                    // Clamp velocity
                    float velMag = length(currentVel);
                    if (velMag > maxVelocity) {
                        currentVel = normalize(currentVel) * maxVelocity;
                    }
                    
                    // Reduce velocity when returning to origin (when mouse stops)
                    if (mouseInfluence < 0.01) {
                        currentVel *= damping;
                    }
                    
                    gl_FragColor = vec4(currentVel, 1.0);
                }
            `;
        }

        // Render shader - points with velocity-based color
        // Create UV coordinates for texture sampling
        const uvs = new Float32Array(TOTAL_POINTS * 2);
        for (let i = 0; i < GRID_SIZE; i++) {
            for (let j = 0; j < GRID_SIZE; j++) {
                const idx = i * GRID_SIZE + j;
                uvs[idx * 2] = (j + 0.5) / GRID_SIZE; // x coordinate
                uvs[idx * 2 + 1] = (i + 0.5) / GRID_SIZE; // y coordinate
            }
        }
        
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
        
        const pointMaterial = new THREE.ShaderMaterial({
            uniforms: {
                texturePosition: { value: null },
                textureVel: { value: null },
                pointSize: { value: 10.0 }
            },
            vertexShader: `
                uniform sampler2D texturePosition;
                uniform sampler2D textureVel;
                uniform float pointSize;
                
                varying vec3 vColor;
                
                void main() {
                    vec4 pos = texture2D(texturePosition, uv);
                    vec4 vel = texture2D(textureVel, uv);
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos.xyz, 1.0);
                    gl_PointSize = pointSize;
                    
                    float velMag = length(vel.xyz);
                    
                    // Color based on velocity: blue (0) to red (high)
                    // For medium velocity, mix to purple
                    float normalizedVel = clamp(velMag / 5.0, 0.0, 1.0);
                    
                    if (normalizedVel < 0.5) {
                        // Blue to purple
                        vec3 color1 = vec3(0.0, 0.0, 1.0); // blue
                        vec3 color2 = vec3(0.5, 0.0, 0.5); // purple
                        vColor = mix(color1, color2, normalizedVel * 2.0);
                    } else {
                        // Purple to red
                        vec3 color1 = vec3(0.5, 0.0, 0.5); // purple
                        vec3 color2 = vec3(1.0, 0.0, 0.0); // red
                        vColor = mix(color1, color2, (normalizedVel - 0.5) * 2.0);
                    }
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                
                void main() {
                    // Circular point
                    vec2 coord = gl_PointCoord - vec2(0.5);
                    if (dot(coord, coord) > 0.25) discard;
                    
                    gl_FragColor = vec4(vColor * 3.0, 1.0);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            depthTest: false // Disable depth test for dynamic points
        });

        const points = new THREE.Points(geometry, pointMaterial);
        points.renderOrder = 1; // Render dynamic points after static points
        scene.add(points);

        // Static points for origin grid
        const staticPointMaterial = new THREE.ShaderMaterial({
            uniforms: {
                originTexture: { value: createOriginTexture() },
                pointSize: { value: 5.0 } // Smaller size for static dots
            },
            vertexShader: `
                uniform sampler2D originTexture;
                uniform float pointSize;
                
                void main() {
                    vec4 origin = texture2D(originTexture, uv);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(origin.xyz, 1.0);
                    gl_PointSize = pointSize;
                }
            `,
            fragmentShader: `
                void main() {
                    // Circular point
                    vec2 coord = gl_PointCoord - vec2(0.5);
                    if (dot(coord, coord) > 0.25) discard;
                    
                    gl_FragColor = vec4(0.0, 1.0, 0.0, 0.1); // Green color
                }
            `,
            transparent: true,
            blending: THREE.NormalBlending, // Normal blending for static points
            depthWrite: true, // Write to depth buffer for static points
            depthTest: true // Test depth for static points
        });

        // const staticPoints = new THREE.Points(geometry, staticPointMaterial); // Reuse geometry
        // scene.add(staticPoints);

        // Mouse tracking
        const mouse = new THREE.Vector2();
        let mouseMoving = false;
        let mouseMoveTimeout = null;
        let mousePressed = false;

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            mouseMoving = true;
            
            if (mouseMoveTimeout) {
                clearTimeout(mouseMoveTimeout);
            }
            
            mouseMoveTimeout = setTimeout(() => {
                mouseMoving = false;
            }, 500);
        }

        function onMouseDown(event) {
            mousePressed = true;
        }

        function onMouseUp(event) {
            mousePressed = false;
        }

        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mouseup', onMouseUp);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update mouse position and influence
            const mouseInfluence = mouseMoving ? 1.0 : 0.0;
            uniformsPosition.mouseInfluence.value = mouseInfluence;
            uniformsVelocity.mouseInfluence.value = mouseInfluence;
            uniformsVelocity.mousePressed.value = mousePressed ? 1.0 : 0.0;
            
            uniformsPosition.mousePos.value.set(mouse.x, mouse.y);
            uniformsVelocity.mousePos.value.set(mouse.x, mouse.y);
            
            // Run compute shaders
            gpuCompute.compute();
            
            // Update render uniforms with compute textures
            pointMaterial.uniforms.texturePosition.value = gpuCompute.getCurrentRenderTarget(positionVariable).texture;
            pointMaterial.uniforms.textureVel.value = gpuCompute.getCurrentRenderTarget(velocityVariable).texture;
            
            composer.render(); // Render through the composer
        }

        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight); // Resize composer
            bloomPass.setSize(window.innerWidth, window.innerHeight); // Resize bloom pass
        }
        window.addEventListener('resize', onWindowResize);

        animate();
    </script>
    <p class="instructions">click to repel</p>
    <p class="credits">
        <a href="https://github.com/jakedowns/jakedowns.github.io">View on Github.com/jakedowns</a>
    </p>
</body>
</html>
